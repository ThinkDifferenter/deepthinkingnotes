<!-- TOC -->

- [**一、Class文件结构**](#一class文件结构)
- [**二、字节码指令集**](#二字节码指令集)
- [**三、类的加载过程**](#三类的加载过程)
- [**四、类的加载器**](#四类的加载器)

<!-- /TOC -->


# **一、Class文件结构**
1. 想要让一个Java程序正确地运行在JVM中，Java源码就必须要被编译为符合JVM规范的字节码。前端编译器的主要任务就是负责将**符合Java语法规范的Java代码**转换为**符合JVM规范的字节码**。

2. *字节码文件里是什么?*源代码经过编译器编译之后便会生成一个字节码文件，字节码是一种二进制的类文件，它的内容是JVM的指令，而不像C、C++经由编译器直接生成机器码。(字节码是面向JVM的；而机器指令是面向处理器的)

3. *什么是字节码指令(byte code)?*Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码(opcode)以及跟随其后的零至多个代表此操作所需参数的操作数(operand)所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。

4. class文件格式:Class 的结构不像XML等描述语言，由于它没有任何分隔符号。所以在其中的数据项，无论是字节顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。class文件格式采用一种类似于C语言结构体的方式进行数据存储，这种结构中只有两种数据类型无符号数和表。
    - 无符号数属于基本的数据类型，以u1、u2、u4、u8 来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。
    - 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明

5. class文件的结构并不是一成不变的，随着Java虚拟机的不断发展，总是不可避免地会对Class文件结构做出一些调整，但是其基本结构和框架是非常稳定的。

6. class文件结构： 
    | 类型 | 名称 | 说明 | 长度 | 数量 |
    | :-----| :---- | :---- |:---- |:---- |
    | u4 | magic  | 魔数，识别Class文件格式 | 4个字节  | 1 |
    | u2 | minor_version | 副版本号(小本版) | 2个字节  | 1 | 
    | u2 | major_version | 主版本号(大版本) | 2个字节  | 1 | 
    | u2 | constant_pool_count | 常量池计数器 | 2个字节 | 1 | 
    | cp_info | constant_pool  | 常量池表  | n个字节  | constant_pool_count-1 | 
    | u2 | access_flags | 访问标识 | 2个字节 | 1 | 
    | u2 | this_class   | 类索引   | 2个字节 | 1 | 
    | u2 | super_class  | 父类索引 | 2个字节 | 1  | 
    | u2 | interface_count | 接口计数器 | 2个字节 | 1 | 
    | u2 | interface | 接口索引集合 | 2个字节 | interfa_count | 
    | u2 | field_count | 字段计数器 | 2个字节 | 1 | 
    | field_info | fields | 字段表集合 | n个字节  | field_count | 
    | u2 | methods_count | 方法计数器 | 2个字节 | 1 | 
    | method_info | methods | 方法表集合 | n个字节 | method_count | 
    | u2 | attributes_count | 属性计数器 | 2个字节  | 1 | 
    | attribute_info | attributes | 属性表集合 | n个字节  | attributes_count | 

7. 魔数(0xCAFEBABY)：使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。

8. 副版本号&主版本号：不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件,但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件。否则JVM会抛出java.lang.UnsupportedClassVersionError异常。（向下兼容)

9. 常量池计数器&常量池：常量池是Class文件中内容最为丰富的区域之一。常量池对于Class文件中的字段和方法解析也有着至关重要的作用.随着Java虚拟机的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个class文件的基石。

10. 常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。注意：常量池计数器的值是从1而不是从0开始计数！即constant_pool_count = 1，表示常量池中的没有任何项。

11. 通常我们写代码时都是从O开始的，但是这里的常量池却是从1开始，因为它把第0项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值0来表示。

12. 常量池包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，即常量数据类型，这个字节称为tag byte（标记字节、标签字节）。常量类型与标记对应关系如下表(共14中数据类型)：
    | 类型 | 标记 | 描述 |
    | :--- | :--- | :--- |
    | CONSTANT_utf8_info | 1 | UTF-8编码的字符串 |
    | CONSTANT_Integer_info | 3 | 整型字面量 | 
    | CONSTANT_Float_info | 4 | 浮点型字面量 |
    | CONSTANT_Long_info | 5 | 长整型字面量 | 
    | CONSTANT_Double_info | 6 | 双精度浮点型字面量 |
    | CONSTANT_Class_info | 7 | 类或接口的符号引用 | 
    | CONSTANT_String_info| 8 | 字符串类型字面量 |
    | CONSTANT_Fieldref_info | 9 | 字段的符号引用 |
    | CONSTANT_Methodref_info | 10 | 类中方法的符号引用 |
    | CONSTANT_InterfaceMethodref_info | 11 | 接口中方法的符号引用 |
    | CONSTANT_NameAndType_info | 12 | 字段或方法的符号引用 |
    | CONSTANT_MethodHandle_info | 15 | 表示方法句柄 | 
    | CONSTANT_MethodType_info | 16 | 标志方法类型 |
    | CONSTANT_InvokeDynamic_info | 18 | 表示一个动态方法调用点 |

13. 字面量(Literal)包括文本字符串、声明为final的常量值；符号引用(Sysbolic References)包括类和接口的全限定名、字段的名称和描述符、方法的名称描述符。

14. 几个重要的概念：
    - 全限定名：com/atguigu/test/Demo这个就是类的全限定名，仅仅是把包名的"."替换成"/"，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。
    - 简单名称：不带类型和参数的方法或者字段名称，上面例子中的类的add()方法和num字段的简单名称分别是add和num
    - 描述符：描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则基本数据类型(byte、char、double、float、int、long、short、boolean)以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法java.lang.String toString()的描述符为()Ljava/lang/String;，方法int abc(int[]x, int y)的描述符为([II)I。

15. 虚拟机在加载Class文件时才会进行动态的接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段(链接阶段分为三个步骤 检验、准备、解析)将其替换为直接引用，并翻译到具体的内存地址中。这里说明下符号引用和直接引用的区别与关联:
    - 符号引用:符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。
    - 直接引用:直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定己经存在于内存之中了。

16. 常量池总结：
    - 这14种表（或者常量项结构）的共同点是:表开始的第一位是一个u1类型的标志位(tag)，代表当前这个常量项使用的是哪种表结构，即哪种常量类型。
    - 在常量池列表中，CONSTANT_utf8_info常量项是一种使用改进过的UTF-8编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。
    - 这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_utf8_info占用字节不固定，其大小由length决定。因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过utf-8编码，就可以知道其长度。
    - 常量池:可以理解为Class文件之中的资源仓库, 它是Class文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用class文件空间最大的数据项目之一。
    - Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态链接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换(解析)的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

17. 访问标记:该标记使用两个字节表示(通常以ACC_开头)，用于识别一些类或者接口层次的访问信息，包括:这class是类还是接口;是否定义为 public类型;是否定义为 abstract类型;如果是类的话，是否被声明为 final
等。各种访问标记如下所示:
    | 标志名称 | 标志值 | 含义 |
    | :------ | :----- | :----|
    | ACC_PUBLIC | 0x0001 | 标志为public类型 |
    | ACC_FINAL | 0x0010 | 标志被声明为final，只有类可以设置 |
    | ACC_SUPER | 0x0020 | 标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。(使用增强的方法调用父类方法)|
    | ACC_INTERFACE | 0x0200 | 标志这是一个接口 |
    | ACC_ABSTRACT | 0x0400 | 是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类型为假 |
    | ACC_SYNTHETIC | 0x1000 | 标志此类并非由用户代码产生(即:由编译器产生的类，没有源码对应) |
    | ACC_ANNOTATION | 0x2000 | 标志这是一个注解 |
    | ACC_ENUM | 0x4000 | 标志这是一个枚举 |

18. 访问标记总结：
    - 1．带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。如果一个class文件被设置了ACC_INTERFACE标志，那么同时也得设置ACC_ABSTRACT标志。同时它不能再设置 ACC_FINAL、Acc_SUPER或ACC_ENUM标志；如果没有设置ACC_INTERFACE标志，那么这个class文件可以具有上表中除 ACC_AINOTATTON外的其他所有标志。当然，ACC_FINAL和ACC_ABSTRACT这类互斥的标志除外。这两个标志不得同时设置。
    - 2.ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。针对Java虚拟机指令集的编译器都应当设置这个标志。对于Java SE 8及后续版本来说，无论class文件中这个标志的实际值是什么，也不管class文件的版本号是多少，Java虚拟机都认为每个class文件均设置了ACC_SUPER标志。
    - 3.Acc_SYNTHETIC标志意味着该类或接口是由编译器生成的，而不是由源代码生成的；注解类型必须设置ACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，那么也必须设置ACC_INTERFACE标志；ACC_ENUM标志表明该类或其父类为枚举类型。

19. 类索引&父类索引&接口索引集合：类索引用于确定这个类的全限定名；父类索引用于确定这个类的父类的全限定名；由于Java语言不允许多重继承，所以父类索引只有一个，除了
java.lang.0bject 之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为空；接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句(如果这个类本身是一个接口，则应当是extends语句)后的接口顺序从左到右排列在接口索引集合中。

20. 字段表集合：用于描述接口或类中声明的变量。字段(field)包括类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量以及从父类或父类接口继承的那些字段。字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符（public、private或protected)、是类变量还是实例变量(static修饰符）、是否是常量(final修饰符）等。

21. 字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。
在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。

22. 一个字段的信息包括如下这些信息。这些信息中，各个修饰符都是布尔值，要么有，要么没有。作用域(public、 private、protected修饰符)；是实例变量还是类变量(static修饰符)；可变性(final)；并发可见性(volatile修饰符，是否强制从主内存读写)；可否序列化（transient修饰符)；字段数据类型（基本数据类型、对象、数组）；字段名称

23. 字段表(field_info)结构如下：
    | 类型 | 名称 | 含义 | 数量 |
    | :--- | :--- | :--- | :--- |
    | u2 | access_flags | 字段访问标志 | 1 |
    | u2 | name_index | 字段名索引 | 1 |
    | u2 | descriptor_index | 描述符索引 | 1 |
    | u2 | attributes_count | 属性计数器 | 1 |
    | attribute_info | attributes | 属性集合 | attributes_count |


24. 方法表集合：指向常量池索引集合，它完整描述了每个方法的签名。在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符(public、private或protected),方法的返回值类型以及方法的参数信息等。一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息(比如:类(接口)初始化方法< clinit>()和实例初始化方法< init>())。

25. 方法表注意事项:在Java语言中，要重载(Overload)一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中。也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和Java语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。

26. methods表中的每个成员都必须是一个method_info结构，用于表示当前类或接口中某个方法的完整描述。如果某个method_info结构的access_flags项既没有设置 ACC_NATIVE标志也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法方法表的结构实际跟字段表是一样的，方法表结构(method_info)如下:
    | 类型 | 名称 | 含义 | 数量 |
    | :--- | :--- | :--- | :--- |
    | u2 | access_flags | 方法访问标志 | 1 |
    | u2 | name_index | 方法名索引 | 1 |
    | u2 | descriptor_index | 描述符索引 | 1 |
    | u2 | attributes_count | 属性计数器 | 1 |
    | attribute_info | attributes | 属性集合 | attributes_count |

27. 属性表集合：指的是class文件所携带的辅助信息，比如该class文件的源文件的名称。字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与己有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉它不认识的属性。

28. 属性表的每个项的值必须是attribute_info结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。属性表(attribute_info)的通用格式如下：
    | 类型 | 名称 | 含义 | 数量 |
    | :--- | :--- | :--- | :--- |
    | u2 | attribute_name_index | 属性名索引 | 1 |
    | u4 | attribute_length | 属性长度(唯一一个长度标识为4个字节的) | 1 |
    | u1 | info | 属性表 | attribute_length |

29. 反解析指令使用组合 javap -v -p ***.class

30. class文件结构官方参考文档 [The ClassFile Structure](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html)


# **二、字节码指令集**
1. Java虚拟机的指令由**一个字节长度的**、代表着某种特定操作含义的数字(称为操作码，Opcode)以及跟随其后的零至多个代表此操作所需参数(称为操作数，Operands)而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。由于限制了Java虚拟机操作码的长度为一个字节(即0~255)，这意味着指令集的操作码总数不可能超过256条。
熟悉虚拟机的指令对于动态字节码生成、反编译Class文件、Class文件修补都有着非常重要的价值。

2. 字节码执行模型：如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解:
    ```java
    do{
        自动计算PC寄存器的值加1;
        根据PC寄存器的指示位置，从字节码流中取出操作码;
        if(字节码存在操作数)从字节码流中取出操作数;
        执行操作码所定义的操作;
    }while(字节码长度>0);
    ```

3. 大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展(Sign-Extend)为相应的int类型数据，将boolean和char类型数据零位扩展〈(Zero-Extend)为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。

4. JVM中的字节码指令集按用途可大致分成9类：
    - 加载与存储指令：用于将数据从栈帧的局部变量表和操作数栈之间来回传递。
    - 算术指令：
    - 类型转换指令
    - 对象的创建与访问指令·方法调用与返回指令·操作数栈管理指令
    - 比较控制指令
    - 异常处理指令
    - 同步控制指令

5. 在做值相关操作时:
    - 一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈。
    - 一个指令，也可以从操作数栈中取出一到多个值（pop多次），完成赋值、加减乘除、方法传参、系统调用等等操作。

6. 常用的加载与存储指令：
    - 【局部变量压栈指令】将一个局部变量加载到操作数栈: xload、xload_< n>(其中x为、1、f、d、a, n为日到3)
    - 【常量入栈指令】将一个常量加载到操作数栈: bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_< i>、lconst_< l>、fconst_< f>、dconst_< d>
    - 【出栈装入局部变量表指令】将一个数值从操作数栈存储到局部变量表: xstore、xstore_< n>(其xi、1、f、d、a，n为0到3) ; xastore（其中xoi、1、f、d、a、b、c、s)
    - 扩充局部变量表的访问索引的指令: wide。
    
7. 对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。操作byte、char、short和boolean类型数据时，经常用int类型的指令来表示。

8. 操作数栈：执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。

9. 局部变量表：Java 方法栈桢的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。实际上，Java虚拟机将局部变量区当成一个数组，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。和操作数栈一样，long类型以及 double类型的值将占据两个单元，其余类型仅占据一个单元。

10. 常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为const系列、push系列和ldc指令。
    - 指令const系列:用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有: iconst_< i>(i从-1到5)、lconst_< l>(1从0到1)、fconst_< f>(f从e到2)、dconst_< d> (d从0到1)、aconst_null。比如，iconst_m1将-1压入操作数栈;iconst_x (x为9到5）将x压入栈:lconst_0、lconst_1分别将长整数0和1压入栈;fconst_0、fconst_1、fconst_2分别将浮点数0、1、2压入栈;dconst_o和dconst_1分别将double型e和1压入栈。aconst_null将null压入操作数栈;从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i表示整数，1表示长整数，f表示浮点数，d表示双精度浮点，习惯上用a表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。
    - 指令push系列:主要包括bipush和sipush。它们的区别在于接收数据类型的不同，bipush接收8位整数作为参数，sipush接收16位整数，它们都将参数压入栈。
    - 指令ldc系列:如果以上指令都不能满足需求，那么可以使用万能的1dc指令，它可以接收一个8位的参数该参数指向常量池中的int、float或者String的索引，将指定的内容压入堆栈。类似的还有ldc_w，它接收两个8位参数，能支持的索引范围大于ldc。如果要压入的元素是long或者double类型的,则使用ldc2_w指令，使用方式都是类似的。

11. 注意：常量入栈指令中的n和局部变量压栈指令中的n不一样，本次的n代表数值或者对象，而不是局部变量表中的下标。

12. 




























































































































































































# **三、类的加载过程**

























































































































































# **四、类的加载器**











































































































































































