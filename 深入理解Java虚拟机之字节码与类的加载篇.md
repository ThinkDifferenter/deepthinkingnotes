# **一、Class文件结构**
1. 想要让一个Java程序正确地运行在JVM中，Java源码就必须要被编译为符合JVM规范的字节码。前端编译器的主要任务就是负责将**符合Java语法规范的Java代码**转换为**符合JVM规范的字节码**。

2. *字节码文件里是什么?*源代码经过编译器编译之后便会生成一个字节码文件，字节码是一种二进制的类文件，它的内容是JVM的指令，而不像C、C++经由编译器直接生成机器码。(字节码是面向JVM的；而机器指令是面向处理器的)

3. *什么是字节码指令(byte code)?*Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码(opcode)以及跟随其后的零至多个代表此操作所需参数的操作数(operand)所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。

4. class文件格式:Class 的结构不像XML等描述语言，由于它没有任何分隔符号。所以在其中的数据项，无论是字节顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。class文件格式采用一种类似于C语言结构体的方式进行数据存储，这种结构中只有两种数据类型无符号数和表。
    - 无符号数属于基本的数据类型，以u1、u2、u4、u8 来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。
    - 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明

5. class文件的结构并不是一成不变的，随着Java虚拟机的不断发展，总是不可避免地会对Class文件结构做出一些调整，但是其基本结构和框架是非常稳定的。

6. class文件结构： 
    | 类型 | 名称 | 说明 | 长度 | 数量 |
    | :-----| :---- | :---- |:---- |:---- |
    | u4 | magic  | 魔数，识别Class文件格式 | 4个字节  | 1 |
    | u2 | minor_version | 副版本号(小本版) | 2个字节  | 1 | 
    | u2 | major_version | 主版本号(大版本) | 2个字节  | 1 | 
    | u2 | constant_pool_count | 常量池计数器 | 2个字节 | 1 | 
    | cp_info | constant_pool  | 常量池表  | n个字节  | constant_pool_count-1 | 
    | u2 | access_flags | 访问标识 | 2个字节 | 1 | 
    | u2 | this_class   | 类索引   | 2个字节 | 1 | 
    | u2 | super_class  | 父类索引 | 2个字节 | 1  | 
    | u2 | interface_count | 接口计数器 | 2个字节 | 1 | 
    | u2 | interface | 接口索引集合 | 2个字节 | interfa_count | 
    | u2 | field_count | 字段计数器 | 2个字节 | 1 | 
    | field_info | fields | 字段表集合 | n个字节  | field_count | 
    | u2 | methods_count | 方法计数器 | 2个字节 | 1 | 
    | method_info | methods | 方法表集合 | n个字节 | method_count | 
    | u2 | attributes_count | 属性计数器 | 2个字节  | 1 | 
    | attribute_info | attributes | 属性表集合 | n个字节  | attributes_count | 

7. 魔数(0xCAFEBABY)：使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。

8. 副版本号&主版本号：不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件,但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件。否则JVM会抛出java.lang.UnsupportedClassVersionError异常。（向下兼容)

9. 常量池计数器&常量池：常量池是Class文件中内容最为丰富的区域之一。常量池对于Class文件中的字段和方法解析也有着至关重要的作用.随着Java虚拟机的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个class文件的基石。

10. 常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。注意：常量池计数器的值是从1而不是从0开始计数！即constant_pool_count = 1，表示常量池中的没有任何项。

11. 通常我们写代码时都是从O开始的，但是这里的常量池却是从1开始，因为它把第0项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值0来表示。

12. 常量池包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，即常量数据类型，这个字节称为tag byte（标记字节、标签字节）。常量类型与标记对应关系如下表(共14中数据类型)：
    | 类型 | 标记 | 描述 |
    | :--- | :--- | :--- |
    | CONSTANT_utf8_info | 1 | UTF-8编码的字符串 |
    | CONSTANT_Integer_info | 3 | 整型字面量 | 
    | CONSTANT_Float_info | 4 | 浮点型字面量 |
    | CONSTANT_Long_info | 5 | 长整型字面量 | 
    | CONSTANT_Double_info | 6 | 双精度浮点型字面量 |
    | CONSTANT_Class_info | 7 | 类或接口的符号引用 | 
    | CONSTANT_String_info| 8 | 字符串类型字面量 |
    | CONSTANT_Fieldref_info | 9 | 字段的符号引用 |
    | CONSTANT_Methodref_info | 10 | 类中方法的符号引用 |
    | CONSTANT_InterfaceMethodref_info | 11 | 接口中方法的符号引用 |
    | CONSTANT_NameAndType_info | 12 | 字段或方法的符号引用 |
    | CONSTANT_MethodHandle_info | 15 | 表示方法句柄 | 
    | CONSTANT_MethodType_info | 16 | 标志方法类型 |
    | CONSTANT_InvokeDynamic_info | 18 | 表示一个动态方法调用点 |

13. 字面量(Literal)包括文本字符串、声明为final的常量值；符号引用(Sysbolic References)包括类和接口的全限定名、字段的名称和描述符、方法的名称描述符。

14. 几个重要的概念：
    - 全限定名：com/atguigu/test/Demo这个就是类的全限定名，仅仅是把包名的"."替换成"/"，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。
    - 简单名称：不带类型和参数的方法或者字段名称，上面例子中的类的add()方法和num字段的简单名称分别是add和num
    - 描述符：描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则基本数据类型(byte、char、double、float、int、long、short、boolean)以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法java.lang.String toString()的描述符为()Ljava/lang/String;，方法int abc(int[]x, int y)的描述符为([II)I。

15. 虚拟机在加载Class文件时才会进行动态的接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段(链接阶段分为三个步骤 检验、准备、解析)将其替换为直接引用，并翻译到具体的内存地址中。这里说明下符号引用和直接引用的区别与关联:
    - 符号引用:符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。
    - 直接引用:直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定己经存在于内存之中了。

16. 常量池总结：
    - 这14种表（或者常量项结构）的共同点是:表开始的第一位是一个u1类型的标志位(tag)，代表当前这个常量项使用的是哪种表结构，即哪种常量类型。
    - 在常量池列表中，CONSTANT_utf8_info常量项是一种使用改进过的UTF-8编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。
    - 这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_utf8_info占用字节不固定，其大小由length决定。因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过utf-8编码，就可以知道其长度。
    - 常量池:可以理解为Class文件之中的资源仓库, 它是Class文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用class文件空间最大的数据项目之一。
    - Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态链接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换(解析)的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

17. 访问标记:该标记使用两个字节表示(通常以ACC_开头)，用于识别一些类或者接口层次的访问信息，包括:这class是类还是接口;是否定义为 public类型;是否定义为 abstract类型;如果是类的话，是否被声明为 final
等。各种访问标记如下所示:
    | 标志名称 | 标志值 | 含义 |
    | :------ | :----- | :----|
    | ACC_PUBLIC | 0x0001 | 标志为public类型 |
    | ACC_FINAL | 0x0010 | 标志被声明为final，只有类可以设置 |
    | ACC_SUPER | 0x0020 | 标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。(使用增强的方法调用父类方法)|
    | ACC_INTERFACE | 0x0200 | 标志这是一个接口 |
    | ACC_ABSTRACT | 0x0400 | 是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类型为假 |
    | ACC_SYNTHETIC | 0x1000 | 标志此类并非由用户代码产生(即:由编译器产生的类，没有源码对应) |
    | ACC_ANNOTATION | 0x2000 | 标志这是一个注解 |
    | ACC_ENUM | 0x4000 | 标志这是一个枚举 |

18. 访问标记总结：
    - 1．带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。如果一个class文件被设置了ACC_INTERFACE标志，那么同时也得设置ACC_ABSTRACT标志。同时它不能再设置 ACC_FINAL、Acc_SUPER或ACC_ENUM标志；如果没有设置ACC_INTERFACE标志，那么这个class文件可以具有上表中除 ACC_AINOTATTON外的其他所有标志。当然，ACC_FINAL和ACC_ABSTRACT这类互斥的标志除外。这两个标志不得同时设置。
    - 2.ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。针对Java虚拟机指令集的编译器都应当设置这个标志。对于Java SE 8及后续版本来说，无论class文件中这个标志的实际值是什么，也不管class文件的版本号是多少，Java虚拟机都认为每个class文件均设置了ACC_SUPER标志。
    - 3.Acc_SYNTHETIC标志意味着该类或接口是由编译器生成的，而不是由源代码生成的；注解类型必须设置ACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，那么也必须设置ACC_INTERFACE标志；ACC_ENUM标志表明该类或其父类为枚举类型。

19. 类索引&父类索引&接口索引集合：类索引用于确定这个类的全限定名；父类索引用于确定这个类的父类的全限定名；由于Java语言不允许多重继承，所以父类索引只有一个，除了
java.lang.0bject 之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为空；接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句(如果这个类本身是一个接口，则应当是extends语句)后的接口顺序从左到右排列在接口索引集合中。

20. 字段表集合：用于描述接口或类中声明的变量。字段(field)包括类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量以及从父类或父类接口继承的那些字段。字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符（public、private或protected)、是类变量还是实例变量(static修饰符）、是否是常量(final修饰符）等。

21. 字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。
在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。

22. 一个字段的信息包括如下这些信息。这些信息中，各个修饰符都是布尔值，要么有，要么没有。作用域(public、 private、protected修饰符)；是实例变量还是类变量(static修饰符)；可变性(final)；并发可见性(volatile修饰符，是否强制从主内存读写)；可否序列化（transient修饰符)；字段数据类型（基本数据类型、对象、数组）；字段名称

23. 字段表结构
    | 类型 | 名称 | 含义 | 数量 |
    | :--- | :--- | :--- | :--- |
    | u2 | access_flags | 访问标志 | 1 |
    | u2 | name_index | 字段名索引 | 1 |
    | u2 | descriptor_index | 描述符索引 | 1 |
    | u2 | attributes_count | 属性计数器 | 1 |
    | attribute_info | attributes | 属性集合 | attributes_count |


24. 方法表集合：



































































































# **二、字节码指令集**


































































































































































































# **三、类的加载过程**

























































































































































# **四、类的加载器**











































































































































































