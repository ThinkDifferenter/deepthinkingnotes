1. JVM调优的目的：防止出现OOM；解决OOM；减少Full GC出现的频率

2. 性能调优的步骤：性能监控(GC频繁、CPU负载过高、OOM异常、内存泄露、程序响应时间较长) -> 性能分析(打印GC日志、分析Dump文件、使用内存分析工具) -> 性能调优(数据表设计、SQL查询语句、JVM参数设置、项目架构调整)

3. 性能评价指标：
   - 响应时间：一般关注平均响应时间，或者暂停时间，执行垃圾收集时，程序的工作线程被暂停的时间；
   - 吞吐量：即单位时间内完成的工作量(执行工作线程的时间占总的运行时间的比例)
   - 并发数：同一时刻，对服务器有实际交互的请求数。(并发数估计在5%-15%之间)
   - 三者间关系的理解：响应时间越短，意味着任务切换执行的频率越高，

4. JVM监控及诊断工具-CMD：
   - jps:查看正在运行的java程序
   - jstat:查看JVM统计信息，如加载的类、运行时数据区、垃圾收集等相关信息
   - jinfo:实时查看和修改JVM配置参数
   - jmap:导出内存映像文件&内存使用情况 -dump选项，dump文件名的由来
   - jhat:堆分析工具(jhat命令在jdk9及其之后就被移除了，官方建议使用jvisualvm代替jhat，所以该指令只需简单了解一下即可)
   - jstack:打印JVM中线程快照
   - jcmd:多功能命令行

5.  JVM监控及诊断工具-GUI:
    - jconsole
    - jvisualvm
    - MAT
    - JProfiler
  
6. 浅堆(Shallow Heap)是指一个对象所消耗的内存。在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8字节。根据堆快照格式不同，对象的大小会向8字节对齐。
   
7. 保留集(Retained Set):对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合(包括对象A本身)，即对象A的保留集可以被认为是**只能通过对象A**被**直接或间接**访问到的所有对象的集合。通俗地说，就是指仅**被对象A所持有的对象的集合**。

8. 深堆(Retained Heap):深堆是指对象的保留集中所有的对象的浅堆大小之和。注意:浅堆指对象本身占用的内存，**不包括其内部引用对象的大小**。一个对象的深堆指只能通过该对象访问到的(**直接或间接)**所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。
   
9. 当前深堆大小 = 当前对象的浅堆大小 + 对象中所包含对象的深堆大小(间接)

10. 对象实际大小：一个对象所能触及的所有对象的浅堆大小之和，也就是我们通常意义上说的对象大小。对象实际大小与垃圾回收无关。

11. 支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的直接支配者。支配树是基于对象间的引用图所建立的，它有以下基本性质:
    - 对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set)，即深堆。
    - 如果对象A支配对象B，那么对象A的直接支配者也支配对象B。

12. 内存泄露：那些不会再被程序用到了，但是GC没有办法将其回收的对象，这样的现象称为内存泄露。

13. Java中内存泄露的8种情况：
    - 1)静态集合类：如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，**长生命周期的对象持有短生命周期对象的引用**，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。
    - 2)单例模式：和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。
    - 3)内部类持有外部类：如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。
    - 4)各种连接，如数据库连接、网络连接和Io连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。
    - 5)变量不合理的作用域:一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏(**慎用成员变量**)。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。
    - 6)改变哈希值:当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。(当我们想把自己定义的类保存到散列表的时候，需要保证对象的hashCode不可变)
    - 7)缓存泄露：内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。
    - 8)监听器和回调：内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。

14. 

