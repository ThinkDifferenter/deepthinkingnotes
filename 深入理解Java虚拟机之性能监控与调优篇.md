1. JVM调优的目的：**防止出现OOM；解决OOM；减少Full GC出现的频率**

2. 性能调优的步骤：**性能监控**(GC频繁、CPU负载过高、OOM异常、内存泄露、程序响应时间较长) -> **性能分析**(打印GC日志、分析Dump文件、使用内存分析工具) -> **性能调优**(数据表设计、SQL查询语句、JVM参数设置、项目架构调整)

3. 性能评价指标：
   - **响应时间**：一般关注平均响应时间，或者暂停时间，执行垃圾收集时，程序的工作线程被暂停的时间；
   - **吞吐量**：即单位时间内完成的工作量(执行工作线程的时间占总的运行时间的比例)
   - 并发数：同一时刻，对服务器有实际交互的请求数。(**并发数估计在5%-15%之间**)
   - 三者间关系的理解：响应时间越短，意味着任务切换执行的频率越高，

4. JVM监控及诊断工具-CMD：
   - jps:查看正在运行的java程序
   - jstat:查看JVM统计信息，如加载的类、运行时数据区、垃圾收集等相关信息
   - jinfo:实时查看和修改JVM配置参数
   - jmap:导出内存映像文件&内存使用情况 -dump选项，dump文件名的由来
   - jhat:堆分析工具(jhat命令在jdk9及其之后就被移除了，官方建议使用jvisualvm代替jhat，所以该指令只需简单了解一下即可)
   - jstack:打印JVM中线程快照
   - jcmd:多功能命令行

5.  JVM监控及诊断工具-GUI:
    - jconsole
    - jvisualvm
    - MAT
    - JProfiler
    - Arthas(面向服务器，低侵入式监控)
  
6. 浅堆(Shallow Heap)是指**一个对象所消耗的内存**。在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8字节。根据堆快照格式不同，对象的大小会向8字节对齐。(**对象引用+基本数据类型+8字节对齐**)
   
7. 保留集(Retained Set):**对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合(包括对象A本身)**，即对象A的保留集可以被认为是**只能通过对象A**被**直接或间接**访问到的所有对象的集合。通俗地说，就是指仅**被对象A所持有的对象的集合**。

8. 深堆(Retained Heap):深堆是指对象的**保留集**中所有的对象的浅堆大小之和。注意:浅堆指对象本身占用的内存，**不包括其内部引用对象的大小**。一个对象的深堆指只能通过该对象访问到的(**直接或间接)**所有对象的浅堆之和，即**对象被回收后，可以释放的真实空间**。
   
9. 当前深堆大小 = 当前对象的浅堆大小 + 对象中所包含对象的深堆大小(直接&间接)

10. 对象实际大小：**一个对象所能触及的所有对象的浅堆大小之和**，也就是我们通常意义上说的对象大小。对象实际大小与垃圾回收无关。

11. 支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的直接支配者。支配树是基于对象间的引用图所建立的，它有以下基本性质:
    - **对象A的子树(所有被对象A支配的对象集合)表示对象A的保留集(retained set)**，即深堆。
    - **如果对象A支配对象B，那么对象A的直接支配者也支配对象B**。

12. **内存泄露**：那些不会再被程序用到了，但是GC没有办法将其回收的对象，这样的现象称为内存泄露。

13. **Java中内存泄露的8种情况**：
    - 1)静态集合类：如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，**长生命周期的对象持有短生命周期对象的引用**，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。
    - 2)单例模式：和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。
    - 3)内部类持有外部类：如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。
    - 4)各种连接，如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。
    - 5)变量不合理的作用域:一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏(**慎用成员变量**)。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。
    - 6)改变哈希值:当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。(当我们想把自己定义的类保存到散列表的时候，需要保证对象的hashCode不可变)
    - 7)缓存泄露：内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。
    - 8)监听器和回调：内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。

14. JVM的JIT编译模式相关的选项
    - -Xint：只使用解释器：所有字节码都被解释执行，这个模式的速度是很慢的；
    - -Xcomp：只使用编译器：所有字节码第一次使用就被编译成本地代码，然后在执行；
    - -Xmixed：默认模式，刚开始的时候使用解释器慢慢解释执行，后来让JIT即时编译器根据程序运行的情况，有选择地将某些热点代码提前编译并缓存在本地，在执行的时候效率就非常高了。

15. 堆栈相关参数
    - -Xms< size>设置初始Java堆大小，等价于-XX:InitialHeapSize；
    - -Xmx< size>设置最大Java堆大小，等价于-XX:MaxHeapSize；
    - -Xss< size>设置Java线程堆栈大小，等价于-XX:ThreadStackSize。

16. 对于Eden与Survivor比例的说明：只有显示使用Eden区和Survivor区的比例，才会让比例生效，否则比例都会自动设置(6:1:1)，至于其中的原因是-XX:+UseAdaptiveSizePolic选项为默认开启状态，最后推荐使用默认打开的-XX:+UseAdaptiveSizePolicy设置，并且不显示设置-XX:SurvivorRatio

17. OMM相关选项：
    - -XX:+HeapDumpOnOutMemoryError表示在内存出现OOM的时候，生成Heap转储文件，以便后续分析，-XX:+HeapDumpBeforeFullGC和-XX:+HeapDumpOnOutMemoryError只能设置1个
    - -XX:+HeapDumpBeforeFullGC表示在出现FullGC之前，生成Heap转储文件，以便后续分析，-XX:+HeapDumpBeforeFullGC和-XX:+HeapDumpOnOutMemoryError只能设置1个，请注意FullGC可能出现多次，那么dump文件也会生成多个
    - -XX:HeapDumpPath=< path>指定heap转存文件的存储路径，如果不指定，就会将dump文件放在当前目录中
    - -XX:OnOutOfMemoryError指定一个可行性程序或者脚本的路径，当发生OOM的时候，去执行这个脚本
     
18. Serial收集器相关选项：
    - -XX:+UseSerialGC:指定年轻代和老年代都使用串行收集器。等价于新生代用Serial Gc，且老年代用Serial old GC。可以获得最高的单线程收集效率。

19. ParNew收集器相关选项：
    - -XX:+UseParNewGC手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。(由于没对于的老年代垃圾收集器搭档，最终将被废弃)
    - -XX: ParallelGCThreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。在默认情况下，当CPU 数量小于8个，Paralle1GCThreads 的值等于CPU 数量。当CPU数量大于8个，ParallelGCThreads 的值等于3+[ 5*CPU_Count]/8。

20. Parallel收集器相关选项：
    - -XX:+UseParallelGc手动指定年轻代使用Paralle1并行收集器执行内存回收任务。
    - -XX:+UseParallelOldGc手动指定老年代都是使用并行回收收集器。分别适用于新生代和老年代。默认jdk8是开启的。上面两个参数，默认开启一个，另一个也会被开启。(互相激活)
    - -XX:ParallelGCThreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。
    - -XX:MaxGCPauseMillis设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒。为了尽可能地把停顿时间控制在MaxGCPauseNills以内，收集器在工作时会调整Java堆大小或者其他一些参数。对于交互较强的用户端程序来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量，所以服务器端适合Parallel，进行控制。
    - -XX:GCTimeRatio垃圾收集时间占总时间的比例(= 1/ (N + 1))。用于衡量吞吐量的大小。取值范围(0,100)。默认值99，也就是垃圾回收时间不超过1%。与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Ratio参数就容易超过设定的比例。
    - -XX:+UseAdaptivesizePolicy设置Parallel Scavenge收集器具有自适应调节策略。在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量(GCTimeRatio)和停顿时间(MaxGCPauseNills)，让虚拟机自己完成调优工作。
    
21. CMS收集器相关选项：
    - -XX:+UseConcMarkSweepGC手动指定使用CMS 收集器执行内存回收任务。开启该参数后会自动将-XX:+UseParNewGC打开。即:ParNew(Young区用)+CNS(o1d区用) +Serial Old的组合。
    - -XX:CMS1nitiatingOccupanyFraction设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68,即当老年代的空间使用率达到68%时，会执行一次CNS回收。JDK6及以上版本默认值为92%；如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阙值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。
    - -XX:+UseCNSCompactAtFullCollection用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。
    - -XX:CNSFul11GCsBeforeCompaction设置在执行多少次Full GC后对内存空间进行压缩整理。
    - -XX:ParallelCMSThreads设置CMS的线程数量。CMS 默认启动的线程数是(Paralle1GCThreads+3)/4，Parallel6CThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。
    - JDK9 CMS被标记为弃用；JDK14 CMS被移除

22. G1收集器相关选项：
    - -XX:+UseG1GC手动指定使用G1收集器执行内存回收任务。
    - -XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32NB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。
    - -XX:MaxGCPauseMillis设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms(G1提出的目标就是在保证设定响应时间的基础上尽可能的提高吞吐量)
    - -XX:Paralle1GCThread设置STW时GC线程数的值。最多设置为8
    - -XX:ConcGCThreads设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右。
    - -XX:InitiatingHeapOccupancyPercent设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发Gc。默认值是45。
    - -XX:G1NewSizePercent、-XX:G1MaxNewSizePercent新生代占用整个堆内存的最小百分比(默认5%)、最大百分比(默认60%)
    - -XX:G1ReservePercent=10保留内存区域，防止to space(Survivor中的to区)溢出

23. 注意：
    - 1.Parallel回收器主打吞吐量，而CMS和G1主打低延迟，如果主打吞吐量，那么就不应该限制最大停顿时间，所以-XX:MaxGCPauseMills不应该设置；
    - 2.-XX:MaxGCPauseMills中的调整堆大小通过默认开启的-XX:+UseAdaptiveSizePolicy来实现；
    - 3.-XX:GCTimeRatio用来衡量吞吐量，并且和-XX:MaxGCPauseMills矛盾，因此不会同时使用

24. 如何选择垃圾回收器：
    - 优先调整堆的大小让JVM自适应完成。
    - 如果内存小于100M，使用串行收集器
    - 如果是单核、单机程序，并且没有停顿时间的要求，串行收集器
    - 如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择   
    - 如果是多CPU、追求低停顿时间，需快速响应(比如延迟不能超过1秒，如互联网应用)，使用并发收集器。官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。

25. 特别说明:
    - 1.没有最好的收集器，更没有万能的收集;
    - 2.调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器

26. 通过Java代码获取JVM参数的两种方式：
    - RunTime.getRunTime()
    - ManagementFactory.getMemoryMXBean()

27. GC日志参数：
    - -XX:+PrintGC 输出GC日志。类似：-verbose:gc
    - -XX:+PrintGCDetails在发生垃圾回收时打印内存回收相处的日志， 并在进程退出时输出当前内存各区域分配情况
    - -XX:+PrintGCTimeStamps输出GC发生时的时间戳
    - -XX:+PrintGCDateStamps输出GC发生时的时间戳(以日期的形式，例如：2013-05-04T21:53:59.234+0800)
    - -XX:+PrintHeapAtGC每一次GC前和GC后，都打印堆信息
    - -Xloggc:< file>表示把GC日志写入到一个文件中去，而不是打印到标准输出中

28. 哪些情况会触发Full GC：老年代空间不足、方法区空间不足、显示调用System.gc()、Minior GC进入老年代的数据的平均大小 大于 老年代的可用内存、大对象直接进入老年代，而老年代的可用空间不足。