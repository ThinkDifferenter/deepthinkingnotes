# **Part 1：Java 基础知识**
1. Java变量分类：局部变量 & 成员变量；其中成员变量又可分为 静态变量(类变量) & 实例变量)

2. 数组为空，不代表数组没有创建；数组一旦创建，其长度就是确定的

3. 多态的使用前提：类的继承关系；方法的重写

4. 静态方法不能被重写！父类、子类可具有同名的静态方法，但不是重写！

5. 何为线程安全：1.如果只有一个线程才可以操作此数据，则必是线程安全的；2.如果有多个线程操作此数据，则此数据是共享数据，如不考虑同步机制的话，会存在线程安全问题

6. 静态初始化块(类的初始化，即类在加载到内存时所执行的代码块，而每个类只被加载一次，静态代码块只会被执行一次)；初始化块(每个类的对象创建时均会执行的代码块)；构造函数(类的特定对象创建时执行的代码块)

7. 类的初始化，即在类加载阶段中的初始化操作，对应的虚拟机层面的方法为 clinit;类对象的初始化，即在方法中创建类的对象并在堆中分配实例内存时的操作，对应的虚拟机层面的方法为 init

8. Java方法分类：实例方法 & 类方法

9. String str = "Hello";// 字面量定义  String str = new String("Hello");// 对象创建定义。其中，以字面量形式定义的字符串会自动添加到字符串常量池中，而用new的方式创建字符串对象会在堆中分配内存(堆中处字符串常量池以外的区域)存储该字符串对象，因此不会添加到字符串常量池中。如需将该字符串对象存储的字符串动态添加到字符串常量池，调用intern()方法即可。

10. String的底层实现由Java8及以前的char数组编程Java8以后的byte数组。而数组在编译时长度就确定了，故字符串是一个不可变的对象

11. String的intern()方法:在程序运行时，向字符串常量池(字符串常量表StringTable)中动态添加字符串常量。如果字符串常量池中没有添加的字符串，则在常量池中添加新的字符串常量，若字符串常量池中存在要添加的字符串，则不再重新添加，复用已有字符串即可，判断要添加的字符串常量是否存在，是通过Hashtable的哈希算法来判断。Java6及之前的Hashtable长度为1009，Java7之后的Hashtable长度为60013，Hashtable长度的增加可以降低字符串常量添加时的哈希冲突，提高判断字符串是否存在的效率。

12. intern()方法的执行过程：先通过hashcode判断要添加的字符串是否存在于字符串常量池，若存在则返回该字符串在常量池中的地址。若不存在，则在字符串常量池中分配内存存储该字符串。

13. Java在做字符串拼接操作时，若"+"号左右有变量存(非final)在，则底层会创建StringBuilder对象并调用append()方法做字符串的链接操作。说明：在Java5之前使用的是StringBuffer对象来做字符串的连接操作，该类线程安全，但性能较低，故更换为StringBuilder。若字符串拼接操作的两端均为字符串常量或字符串常量的引用(final修饰的字符串)，则使用编译期优化，底层实现同字符串常量的连接操作。建议：在定义各种量时，能够使用final时建议加上final!

14. 字符串连接操作的两种方式:① 采用字符串连接操作符的形式 ② 采用StringBuilder对象并调用append()方法的方式；相比之下，前者每次做连接操作时需要创建一个StringBuilder对象和调用toString()方法时，需要创建String对象。一方面在需要做大量连接操作的场景中，每次连接操作创建对象需要花费一定时间，另一方面，创建的对象会占用堆空间的内存并在进行垃圾回收时需要花费一定时间。对于使用StringBuilder对象并调用append()方法的方式，不论做多少次字符串的连接操作，始终只有一个StringBuilder对象存在，可以优化的点在于创建StringBuilder对象时可以根据具体业务需求指定StringBuilder的大小，减少StringBuilder对象频繁扩容所带来的额外开销。

15. 创建字符串常量并添加到字符串常量池方式：①通过字面量的方式定义字符串 String str = "java" ; ②通过 ***.intern()的方式向常量池中动态添加字符串常量，具体形式如 String str = new String("java").intern() | new StringBuilder("java").toString().intern()。


# **Part 2：JVM虚拟机**
1. JVM栈中，本地变量表的基本存储单位是Slot(变量槽)，存放的数据有基本数据类型、引用数据类型和ReturnAddress类型；其中byte、short、char、boolean在存储前转换为int;float,double占两个槽位

2. byte、short、char,在生成的对应字节码并加入操作数栈时会根据数据大小选择最小的数据存储字节码指令，但在返回时统一按照int类型返回

3. 动态类型语言 & 静态类型语言：前者的数据类型是在运行时确定的，即数据的类型是根据数据本身运行时判定，代表语言为弱类型语言；后者对的数据类型是在编译时确定的，即数据的类型是根据数据的类型标识符编译时确定，代表语言为强类型语言。

4. Java方法的调用：动态链接 & 静态链接； 早起绑定 & 晚期绑定； 本质均为：符号引用 -> 直接引用

5. 局部变量是否线程安全？看具体的情况！本质上，若一个局部变量在方法内部定义且在方法内部消亡，没有被其他线程访问的机会，则该局部变量线程安全。如果局部变量以形式参数传入或返回到方法体外，能被其他线程触及到的清楚则该局部变量线程不安全。局部变量是否发生逃逸，局部变量发生逃逸，即为线程不安全的；没有发生逃逸，即为线程安全的。

6. Java语言是一种跨平台的语言，即Java语言能在各大操作系统上的JVM里面运行，而不需要考虑底层兼容问题；JVM虚拟机是一种跨语言的平台，即任何编译成符合JVM虚拟机规范的字节码文件的语言，都能在JVM上运行，如Jpthon、Kotlin、Groovy、Scala等语言

7. 程序虚拟机 & 系统虚拟机：程序虚拟机是专门为单个计算机程序设计的，底层的执行还是交给操作系统，程序虚拟机的代表为Java虚拟机；而系统虚拟机是对物理计算机的仿真，包括虚拟的CPU、内存和磁盘等，它提供了可运行操作系统的，系统虚拟机的代表为VMWare

8. 一个Java进程对应着一个JVM虚拟机实例，一个JVM虚拟机实例就对应着一个堆内存

9. 一个对象的引用出栈后，在堆中的对象实例并不会立马被回收，而是当堆空间不够时触发GC后才被垃圾回收器回收。若一个方法调用完成，对应的栈帧出栈后，该方法所涉及的实例对象立马被回收的话，由于方法的调用是十分频繁的，那么GC操作也会很频繁，从而导致用户线程需要Stop the world,最终导致系统在用户线程速度很慢，吞吐率大大降低

10. 堆空间中包含新生代&老年代，不包括永久代(JDK7及以前版本)或元数据区(JDK8及以后版本)，方法区是JVM运行时数据区的一个逻辑结构，具体的实现是永久代或元数据区。存放的信息有类型信息、域信息、方法信息以及运行时常量池。

11. -Xms：用来设置堆空间初始大小，-X为虚拟机参数；ms即memory start;-Xmx：用来设置堆空间的最大值；默认堆空间大小：初始堆空间大小为物理内存的1/64；最大堆空间大小为物理内存的1/4;

12. 在生产环境中建议将初始堆内存和最大堆内存设置相同值，避免堆空间的扩容和缩小带来的性能问题。

13. -XX:NewRatio：设置新生代与老年代的比例，默认为1:2，新生代占1，老年代占2；一般情况不会修改该比例！

14. 新生代中的Eden：S0：S1 = 8:1:1；由于自适应策略的存在，故新生代中内存比例默认为6:1:1；要想是8需要通过参数-XX:SurvivorRatio显示设置

15. MinorGC触发时机在Eden区满时，而Survivor区满时并不会触发MinorGC。当Eden区进行Minor回收时Survivor From区会一起进行垃圾回收。当Survivor区满时，特殊的处理方式是直接将该对象提升到老年区。

16. 新生代中Eden区设置过大，Survivor区的空间会变小，从而导致Survivor中存放的对象数目变少，新分配的对象会直接进入老年代。MinorGC失去意义，由于老年代中对象不断增加，会导致MajorGC的频繁出发，降低了用户线程的执行效率。

17. 新生代中Survivor区设置过大，Eden区设置过小，那么MinorGC会比较频繁的发生，从而导致用户线程执行效率低下。

18. 对象实例化过程：加载类型信息 -> 为对象分配内存 -> 处理内存分配的并发问题 -> 属性的默认初始化(零值初始化) -> 设置对象头信息(类信息、hashCode信息、GC信息) -> 显示初始化(初始化块、构造函数)

19. Java生态为什么要引入字节码这个中间的文件存储形式：对于Java语言，JVM中的执行引擎完全可以直接将Java源代码直接编译或解释成机器指令并执行。但这样做，一方面直接在源代码编译成机器指令所需的时间会比较长，另一方面，JVM虚拟机无法成为一个跨语言的平台，因为对于每一中要依托于JVM体系的语言来说，JVM必须听相应语言的编译器或解析器，这样一来，新的语言要加入并依托JVM体系的成本会比价高，基本上需要定制该语言的执行引擎，这也是引入字节码最主要的意图。有了字节码这样中间存储形式，新加入JVM体系的语言只需通过该语言的前端编译器，将该语言的源代码编译成符合JVM规范的字节码文件即可，后面的工作放心交给JVM去执行就好。这样既降低了加入Java体系的门槛，另一方面是JVM称为了真正意义上跨语言的平台，并是多语言混合式编程称为可能。

20. 

21. 