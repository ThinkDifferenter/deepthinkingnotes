# **一、Java与JVM结构体系**

1. 学习JVM的目的一方面是根据具体应用场景对JVM进行**性能调优**，另一方面是能够深入理解Java程序的执行过程，从而对运行时发生的错误能够**快速定位并处理**。

2. **内存动态分配**与**垃圾收集机制**为我们打理了很多繁琐的工作，大大提高了开发的效率。但是垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和**诊断运行时问题**的基础。

3. Java虚拟机不关心“字节码”文件是由何种语言编译过来，更不会关心运行在其内部的程序到底是使用何种编程语言编写的。**Java虚拟机拥有语言无关性**，并不会单纯地面向Java语言，只要其他编程语言能够将自己编译成符合Java虚拟机规范的字节码就行，这样Java虚拟机就会认为它是一个有效的字节码文件，从而能够被虚拟机所识别并装载运行。

4. Java平台上的**多语言混合编程**正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们**最终都运行在一个虚拟机**之上。Java虚拟机不仅是面向Java语言，它成为一个跨语言的平台，面向所有将自己编译成符合Java虚拟规范的字节码的语言。

5. **Java技术的核心就是Java虚拟机**，其次才是Java语言本身的语言设计。

6. 系统虚拟机 & 程序虚拟机 (无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于**虚拟机提供的资源**中)

7. JVM架构模型：
   - 基于栈的指令集架构：设计和实现更简单;指令集更小(8位)；相同的操作需要更多的指令；不需要硬件支持；可移植性更好，更好**实现跨平台**(JVM 虚拟机采用基于栈的指令集架构)
   - 基于寄存器的指令集架构：设计和实现更复杂;指令集更大(16位)；相同的操作需要更少的指令；需要硬件支持；可移植性较差，**更好执行性能**

8. JVM生命周期：虚拟机的启动(通过引导类加载器启动) -> 虚拟机的执行(Java程序被Java虚拟机执行) -> 虚拟机的退出(执行结束、错误或异常终止、操作系统错误等)

9. TaobaoVM：创新的**GCIH** (Gc invisible heap ）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且cc不能管理GcIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。GCIH中的对象还能够在**多个Java虚拟机进程中实现共享**。



# **二、类加载子系统**

1. ClassLoader**只负责class文件的加载**，至于它是否可以运行，则由**ExecutionEngine**决定。加载的类信息存放于一块称为方法区的内存空间。除了类的信息外方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量。

2. 类加载过程：加载 -> 链接(具体又细分为校验、准备、解析) - 初始化

3. 加载(Loading)：通过一个**类的全限定名**获取定义此类的**二进制字节流**并将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。类的加载是以字节流的形式进行的。

4. 链接(Linking)：
   - 验证(Verify):目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，**不会危害虚拟机自身安全**。主要包括文件格式验证、元数据验证、字节码验证、符号引用验证；
   - 准备(Prepare):为**类变量**分配内存并且设置该类变量的默认初始值，即零值(**默认初始化**)。这里不包含用final修饰的static，因为final在编译的时候就会分配了，也不会为实例变量分配初始化，**类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中**。
   - 解析(Resolve):将**常量池内的符号引用转换为直接引用**的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。

5. 初始化(Initializetion):初姞化阶段就是执行**类构造器方法**< clinit >的过程，此方法不需定义，是javac编译器自动收集**类中的所有类变量的赋值动作和静态代码块中的语句**合并而来。< clinit>()不同于**类的构造器**。(关联:构造器是虚拟机视角下的< init>())·若该类具有父类，JVM会保证子类的< clinit>()执行前，父类的< clinit>()已经执行完毕，虚拟机必须保证一个类的< clinit> ()方法在多线程下被同步加锁。(同样是针对类变量，在此阶段对其进行**显示初始化**，区别类构造器和构造器)

6. 类加载器的分类：各种类加载器之间不是继承关系，**而是一种层次关系**！
   - 引导类加载器(Bootstrap ClassLoader)：用C/C++实现，嵌入在JVM内部；用于**加载Java核心类库**，如扩展类加载器、系统类加载器以及rt.jar包下的所有类；他没有父类加载器！
   - 自定义类加载器(User-defined ClassLoader)：所有**派生于抽象类ClassLoader的类加载器**都划分为自定义类加载器，具体包括扩展类加载器、系统类加载器以及用户定义的、派生于抽象类ClassLoader的加载器，前两者是虚拟机自带的类加载器，无需我们自行定义和实现。
  
7. 扩展类加载器(Extension ClassLoader)：用Java实现，上层类加载器为引导类加载器，从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。

8. 应用程序加载器(Application ClassLoader)：也叫系统类加载器(System ClassLoader)，用Java实现，上层类加载器为扩展类加载器，它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库。该类加载是程序中默认的类加载器，一般来说，**Java应用的类都是由它来完成加载**。

9. 通常使用java虚拟机提供的类加载器就能够完成正常的开发任务了，为什么要自定义类加载器？
    - 1)隔离加载类：在使用框架时，为了保证他们和我们的应用程序是不冲突的，这时我们就需要将两者进行隔离，隔离就需要我们将两者加载不同的类环境当中，所以我们需要自定义类的加载器(通常，框架会实现自己的一套类加载系统，保证自己不与应用程序所使用的包相冲突，主要针对类名，包名相同的情况)。
    - 2)修改类加载的方式：Bootstrap类加载器必然要用到，到其他的类加载器用户可以根据自己的需求，不按照Java提供的类加载方式，对特定的类进行加载。
    - 扩展加载源：除了从本地磁盘、网络等地方去加载class文件，用户还可自定义类加载器从其他地方加载class文件，如数据库中。
    - 3)防止源代码泄露：为了防止源代码泄露和篡改，在对class文件加载的过程中可以进行加密和解密操作。

10. Java虚拟机对class文件采用的是**按需加载**的方式，只有该类被使用时才会被类加载器加载到方法区并生成class对象。加载某个类的class文件时，Java虚拟机采用的是**双亲委派模式**，即把请求交由父类处理它是一种任务委派模式。


11. 双亲委派模式工作原理：宏观上看 它是一个**由下至上，再由上至下**的过程
    - 1)如果一个类加载器收到了类加载请求，它**并不会自己先去加载**，而是把这个请求委托给它上层的加载器去执行;
    - 2)如果上层加载器还存在其上层加载器，则**进一步向上委托，依次递归**,请求最终将到达**顶层的启动类加载器**;
    - 3)如果上层加载器可以完成类加载任务，**就成功返回**，倘若上层加载器无法完成此加载任务，下层加载器才会尝试自己去加载。

12. 双亲委派机制的优势：避免类的重复加载；保护程序安全，防止核心API被随意篡改，如自己定义String类。(java rt.jar中的核心类一般没有main方法)

13. 在JVM中表示两个class对象是否为**同一个类存在**两个必要条件:
   - 1)类的完整类名必须一致，包括包名。
   - 2)加载这个类的classLoader(指classLoader实例对象)必须相同。

14. 在JVM中即使这两个类对象(class对象)来源同一个class文件，被同一个虚拟机所加载，但只要加载它们的**classLoader实例对象**不同，那么这两个类对象也是不相等的。

15. JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个**类加载器的一个引用作为类型信息的一部分保存在方法区中**。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。 (一个类知道他是由哪个类加载器加载的，一个加载器也知道自己加载了哪些类，加载信息是双向存储)

16. 类的主动使用和被动使用：
    - 类的主动使用会导致类的初始化，主动使用的情况：new、静态变量访问、反射、初始化类的子类等
    - 类的被动使用不会导致类的初始化，除了主动使用的情况就是被动使用

17. 注意区分**类的初始化**和**对象的初始化**，前者是在类加载的时候发生，调用的编译层面的方法是< clint>，会在方法区中生成一个class对象；而后者是在new一个对象时发生的，调用的编译层面的方法是< int>，会在堆区中生成一个实例对象。
    



# **三、运行时数据区**

## **Part1 程序计数器**
1. Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会**随着虚拟机启动而创建，随着虚拟机退出而销毁**(堆区、方法区)。另外一些则是与线程一一对应的，这些**与线程对应的数据区域会随着线程开始和结束而创建和销毁**(栈区、程序计数器)。运行时数据区经典模型：堆区、方法区、JVM栈、本地方法栈、程序计数器。

2. 一个JVM上运行一个Java程序，这个java程序可以开多个线程，**每个JVM中运行着唯一的运行时数据区，对应着唯一的一个RunTime实例**。因此可以通过该RunTime实例获取当前运行时数据区的相关信息。

3. 在Hotspot JVM里，**每个线程都与操作系统的本地线程直接映射**。当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。

4. JVM系统线程：虚拟机线程；周期任务线程；GC线程；编译线程；信号调度线程。

5. 程序计数器(Program Counter Register):用来存储指向**下一条字节码指令**的地址,也即将要执行的指令代码。由执行引擎读取下一条指令。运行时数据区最为简单的数据结构，只存储指令地址，没有GC行为，也不会发生ERROR。

6. 程序计数器是一块很小的内存空间，几乎可以忽略不记。也是**运行速度最快的存储区域**。在JVM规范中，每个线程都有它自己的程序计数器，**是线程私有的**，生命周期与线程的生命周期保持一致。任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址;如果是在执行native方法，则是**未指定值（undefned)** 。

7. 程序计数器是**程序控制流的指示器**，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

8. *使用PC寄存器存储字节码指令地址有什么用?* 一方面，CPU需要不停的切换各个线程，这时候切换回来以后，就得知道**线程接着该从哪开始继续执行**；另一方面，程序执行时需要通过改变PC寄存器的值来明确**下一条应该执行什么样的字节码指令**(与程序计数器的作用一致)。

9. *PC寄存器为什么会被设定为线程私有?* 在多线程的环境下，**CPU会不停地在各个线程间做任务切换**，这样必然导致经常中断或恢复，为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法是为每一个线程都分配一个pc寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互千扰的情况。

10. CPU时间片：分配各个程序或线程的**CPU执行时间**。


## **Part2 虚拟机栈**
1. 由于跨平台性的设计，Java采用**基于栈的指令集架构**来设计的。不同平台的CPU结构不同，所以不能采用基于寄存器的指令集架构。因此，虚拟机栈&本地方法栈是运行时数据区的一个重要的数据结构。

2. Java采用基于栈的指令集架构，优点是**支持跨平台，指令集小，编译器容易实现**；缺点是**性能下降，实现同样的功能需要更多的指令**。

3. 栈是运行时的单位，而堆是存储单位。即:栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。**(栈管运行，堆管存储**)

4. Java虚拟机栈：每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，而每一个栈帧对应着一个Java方法的调用。栈是线程私有的，其生命周期同Java线程。

5. 栈是一种快速有效的存储方式，访问速度仅次于程序计数器。栈帧随着方法的调用而创建并压入栈顶，随着方法执行的结束而抛出而释放所占的内存空间，因此对于虚拟栈来说，无需进行额外的垃圾回收操作。

6. Java虚拟机规范允许Java栈的大小是动态可变的，也就是栈的大小可以随着程序的执行动态扩展和收缩。
    - 对于固定大小的Java虚拟机栈，如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机栈将会抛出一个StackOverflowError异常。(程序没有退出条件的递归调用，导致新的栈帧不断压入Java虚拟机栈 -Xss 设置线程分配Java虚拟机栈的最大空间)
    - 对于可变大小的Java虚拟机栈，如果在尝试扩展的时候无法申请到足够的内存或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机栈将会抛出一个OutOfMemoryError异常。(方法调用的栈帧数据较大、过多的方法调用、过多的线程启动)

7. Java虚拟机栈的单位是栈帧(Stack Frame)，程序中的每个方法调用都唯一对应着Java虚拟机栈中的栈帧，栈帧是一个维系着方法执行过程中的各种数据信息的数据集。

8. 在一条活动的线程中，任意一个时间点只会有一个活动栈帧。即当前正在执行的方法所对应的栈帧，这个栈帧叫做当前栈帧(Current Frame),当前正在执行的方法叫做当前方法(Current Method)，定义了当前方法的类就是当前类(Current Class)。

9. 执行引擎上执行的字节码指令只针对当前栈帧进行操作，当前方法内若嵌套调用了另一个方法，则新的方法将成为当前方法，新创建的栈帧将成为当前栈帧。

10. 栈是线程私有的，每个线程创建时都会创建属于自己的栈区。当前方法执行结束时，当前栈帧会将执行结果传回前一个栈帧，包括指令地址和返回数据，并丢弃当前栈帧。这样可以保证方法执行完后回到调用出继续执行，而不至于程序执行出错。

11. Java的方法返回有两种，一种是通过return指引返回；另一种是方法执行出错抛出异常并通过异常表返回到方法调用处。这两种方式均会导致栈帧被弹出。

12. 栈帧中存储的主要信息有：局部变量表(Local Variable)、操作数栈(Operand Stack)、动态链接(Dynamic Linking)、返回地址(Return Address)

13. 局部变量表定义为数组，主要用于存储方法参数和方法内部的局部变量，包括基本数据类型、引用数据类型以及returnAddress。局部变量表的底层实现是数组，因此局部变量表的大小在编译器就确定下来的，而且在程序运行期间，局部变量表的大小不会发生改变。

14. 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。

15. 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后,随着方法栈帧的销毁，局部变量表也会随之销毁。

16. 局部变量表最基本的单位是Slot，除long和double使用两个Slot外，其他的基本数据类型和引用类型均使用一个Slot存储

17. 栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。

18. 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。

19. 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-out）的操作数栈，也可以称之为表达式栈(Expression stack).操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop).

20. 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。栈中的任何一个元素都是可以任意的Java数据类型。32bit的类型占用一个栈单位深度，64bit的类型占用两个栈单位深度。

21. 操作数栈底层是通过数组实现的，但操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈（push）和出栈(pop）操作来完成一次数据访问。Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。

22. 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-stack Cashing）技术，将栈顶元素全部缓在物理cPu的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。

## **Part3 动态链接**
1. 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。

2. 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(symbolic Reference）保存在class文件的常量池里。比如:描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

3. 在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。
   - 早期绑定(静态绑定)：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。
   - 晚期绑定(动态绑定)：如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。

4. 非虚方法：如果方法在编译期就确定了具体的调用版本，这个版木在运行时是不可变的。这样的方法称为非虚方法。静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。其他方法称为虚方法。其他方法均为虚方法。

5. 动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言；即静态类型语言是判断变量自身的类型信息;动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。

6. Java 语言中方法重写的本质:
    - 1)找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。
    - 2)如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束;如果不通过，则返回java.lang.IllegalAccessError异常。
    - 3)否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
    - 4)如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

7. 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表( virtual method table）(非虚方法不会出现在表中)来实现。使用索引表来代替查找。

8. 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。这样就能避免在每次调用方法时都去向上查找对应的具体调用方法，提升了程序执行效率。
   
## **Part4 返回地址**
1. 方法退出有两种情况：正常退出&发送未处理异常。无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

2. 正常完成出口和异常完成出口的区别在于:通过[常完成出口退出的不会给他的上层调用者产生任何的返回值。

3. 一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。在字节码指令中，返回指令包含ireturn(当返回值是boolean、byte、char.short和int类型时使用)、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。


# **四、执行引擎**
1. 








# **五、字符串常量池**
1. 对于new String()操作，**底层创建的对象有两个**，一个是new 出来的字符串对象，另一个是 写入字符串常量池中的字符串常量对象。

2. 对于new String() + new String()操作，**底层创建的对象有五个**，依次为 StringBuilder(字符串连接符)、String & 字符串常量对象、String & 字符串常量对象。更为深入的有String(toString操作)
   
3. 对于new String()操作，首先会在**堆空间的创建一个对象**，其次会在**字符串常量池中写入一个字符串常量**(前提条件是字符串常量池中还没有该字符串)。对于向字符串常量池中写入一个字符串常量，在Java6及以前会在运行时数据区创建一个字符串常量，在Java7及以后只会在字符串常量池中创建一个字符串常量引用指向堆空间中对应的字符串对象，即该字符串常量的地址就为堆空间中对象的地址，这样做可以大大节约存储空间。至于为什么有这样的转变，是因为在Java7及以后版本，字符串常量池的存储位置由方法区移至堆空间，这样字符串常量就与实例对象同在堆空间中，使得字符串常量池中存储指向字符串对象的引用变成可能。

4. 对于new String() + new String()操作，最终只会返回两个字符串连接后的字符串对象，**并不会在字符串常量池中写入对应的字符串常量**。

5. 











# **六、垃圾回收**

1. 并发(Concurrent) & 并行(Parallel)区别:并发是并行的**扩展**、并行是并发的**特例**。

2. 强引用 - 死也不回收(OOM) 软引用 - 不够即回收 弱引用 - 发现即回收 虚引用- 对象回收跟踪














# **七、其他**

1. JVM栈中，本地变量表的基本存储单位是Slot(变量槽)，存放的数据有基本数据类型、引用数据类型和ReturnAddress类型；其中byte、short、char、boolean在存储前转换为int;float,double占两个槽位

2. byte、short、char,在生成的对应字节码并加入操作数栈时会根据数据大小选择最小的数据存储字节码指令，但在返回时统一按照int类型返回

3. 动态类型语言 & 静态类型语言：前者的数据类型是在运行时确定的，即数据的类型是根据数据本身运行时判定，代表语言为弱类型语言；后者对的数据类型是在编译时确定的，即数据的类型是根据数据的类型标识符编译时确定，代表语言为强类型语言。

4. Java方法的调用：动态链接 & 静态链接； 早起绑定 & 晚期绑定； 本质均为：符号引用 -> 直接引用

5. 局部变量是否线程安全？看具体的情况！本质上，若一个局部变量在方法内部定义且在方法内部消亡，没有被其他线程访问的机会，则该局部变量线程安全。如果局部变量以形式参数传入或返回到方法体外，能被其他线程触及到的清楚则该局部变量线程不安全。局部变量是否发生逃逸，局部变量发生逃逸，即为线程不安全的；没有发生逃逸，即为线程安全的。

6. Java语言是一种跨平台的语言，即Java语言能在各大操作系统上的JVM里面运行，而不需要考虑底层兼容问题；JVM虚拟机是一种跨语言的平台，即任何编译成符合JVM虚拟机规范的字节码文件的语言，都能在JVM上运行，如Jpthon、Kotlin、Groovy、Scala等语言

7. 程序虚拟机 & 系统虚拟机：程序虚拟机是专门为单个计算机程序设计的，底层的执行还是交给操作系统，程序虚拟机的代表为Java虚拟机；而系统虚拟机是对物理计算机的仿真，包括虚拟的CPU、内存和磁盘等，它提供了可运行操作系统的，系统虚拟机的代表为VMWare

8. 一个Java进程对应着一个JVM虚拟机实例，一个JVM虚拟机实例就对应着一个堆内存

9. 一个对象的引用出栈后，在堆中的对象实例并不会立马被回收，而是当堆空间不够时触发GC后才被垃圾回收器回收。若一个方法调用完成，对应的栈帧出栈后，该方法所涉及的实例对象立马被回收的话，由于方法的调用是十分频繁的，那么GC操作也会很频繁，从而导致用户线程需要Stop the world,最终导致系统在用户线程速度很慢，吞吐率大大降低

10. 堆空间中包含新生代&老年代，不包括永久代(JDK7及以前版本)或元数据区(JDK8及以后版本)，方法区是JVM运行时数据区的一个逻辑结构，具体的实现是永久代或元数据区。存放的信息有类型信息、域信息、方法信息以及运行时常量池。

11. -Xms：用来设置堆空间初始大小，-X为虚拟机参数；ms即memory start;-Xmx：用来设置堆空间的最大值；默认堆空间大小：初始堆空间大小为物理内存的1/64；最大堆空间大小为物理内存的1/4;

12. 在生产环境中建议将初始堆内存和最大堆内存设置相同值，避免堆空间的扩容和缩小带来的性能问题。

13. -XX:NewRatio：设置新生代与老年代的比例，默认为1:2，新生代占1，老年代占2；一般情况不会修改该比例！

14. 新生代中的Eden：S0：S1 = 8:1:1；由于自适应策略的存在，故新生代中内存比例默认为6:1:1；要想是8需要通过参数-XX:SurvivorRatio显示设置

15. MinorGC触发时机在Eden区满时，而Survivor区满时并不会触发MinorGC。当Eden区进行Minor回收时Survivor From区会一起进行垃圾回收。当Survivor区满时，特殊的处理方式是直接将该对象提升到老年区。

16. 新生代中Eden区设置过大，Survivor区的空间会变小，从而导致Survivor中存放的对象数目变少，新分配的对象会直接进入老年代。MinorGC失去意义，由于老年代中对象不断增加，会导致MajorGC的频繁出发，降低了用户线程的执行效率。

17. 新生代中Survivor区设置过大，Eden区设置过小，那么MinorGC会比较频繁的发生，从而导致用户线程执行效率低下。

18. 对象实例化过程：加载类型信息 -> 为对象分配内存 -> 处理内存分配的并发问题 -> 属性的默认初始化(零值初始化) -> 设置对象头信息(类信息、hashCode信息、GC信息) -> 显示初始化(初始化块、构造函数)

19. Java生态为什么要引入字节码这个中间的文件存储形式：对于Java语言，JVM中的执行引擎完全可以直接将Java源代码直接编译或解释成机器指令并执行。但这样做，一方面直接在源代码编译成机器指令所需的时间会比较长，另一方面，JVM虚拟机无法成为一个跨语言的平台，因为对于每一中要依托于JVM体系的语言来说，JVM必须听相应语言的编译器或解析器，这样一来，新的语言要加入并依托JVM体系的成本会比价高，基本上需要定制该语言的执行引擎，这也是引入字节码最主要的意图。有了字节码这样中间存储形式，新加入JVM体系的语言只需通过该语言的前端编译器，将该语言的源代码编译成符合JVM规范的字节码文件即可，后面的工作放心交给JVM去执行就好。这样既降低了加入Java体系的门槛，另一方面是JVM称为了真正意义上跨语言的平台，并是多语言混合式编程称为可能。

20. 注意区别：运行时常量池 & 字符串常量池 ！ 运行时常量池存储于方法区中，主要包含类信息、属性引用、方法引用以及字面量等信息；字符串常量池(字符串常量表)存储于堆区(Java7及之后)，用于存储字符串常量信息，避免重复创建具有相同字符串的对象。

21. 对于Java新版本的变化可以从以下几个层面关注:语言层面；API层面；底层优化

22. 