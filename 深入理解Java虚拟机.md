# **一、Java与JVM结构体系**

1. 学习JVM的目的一方面是根据具体应用场景对JVM进行**性能调优**，另一方面是能够深入理解Java程序的执行过程，从而对运行时发生的错误能够快速定位并处理。

2. **内存动态分配**与**垃圾收集**机制为我们打理了很多繁琐的工作，大大提高了开发的效率。但是垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和**诊断运行时问题**的基础。

3. Java虚拟机不关心“字节码”文件是由何种语言编译过来，更不会关心运行在其内部的程序到底是使用何种编程语言编写的。**Java虚拟机拥有语言无关性**，并不会单纯地面向Java语言，只要其他编程语言能够将自己编译成符合Java虚拟机规范的字节码就行，这样Java虚拟机就会认为它是一个有效的字节码文件，从而能够被虚拟机所识别并装载运行。

4. Java平台上的**多语言混合编程**正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们**最终都运行在一个虚拟机**之上。Java虚拟机不仅是面向Java语言，它成为一个跨语言的平台，面向所有将自己编译成符合Java虚拟规范的字节码的语言。

5. **Java技术的核心就是Java虚拟机**，其次才是Java语言本身的语言设计。

6. 系统虚拟机 & 程序虚拟机 (无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于**虚拟机提供的资源**中)

7. JVM架构模型：
   - 基于栈的指令集架构：设计和实现更简单;指令集更小(8位)；相同的操作需要更多的指令；不需要硬件支持；可移植性更好，更好**实现跨平台**(JVM 虚拟机采用基于栈的指令集架构)
   - 基于寄存器的指令集架构：设计和实现更复杂;指令集更大(16位)；相同的操作需要更少的指令；需要硬件支持；可移植性较差，**更好执行性能**

8. JVM生命周期：虚拟机的启动(通过引导类加载器启动) -> 虚拟机的执行(Java程序被Java虚拟机执行) -> 虚拟机的退出(执行结束、错误或异常终止、操作系统错误等)

9. TaobaoVM：创新的**GCIH** (Gc invisible heap ）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且cc不能管理GcIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。GCIH中的对象还能够在**多个Java虚拟机进程中实现共享**。



# **二、类加载子系统**

1. ClassLoader**只负责class文件的加载**，至于它是否可以运行，则由**ExecutionEngine**决定。加载的类信息存放于一块称为方法区的内存空间。除了类的信息外方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量。

2. 类加载过程：加载 -> 链接(具体又细分为校验、准备、解析) - 初始化

3. 加载(Loading)：通过一个**类的全限定名**获取定义此类的**二进制字节流**并将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。类的加载是以字节流的形式进行的。

4. 链接(Linking)：
   - 验证(Verify):目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，**不会危害虚拟机自身安全**。主要包括文件格式验证、元数据验证、字节码验证、符号引用验证；
   - 准备(Prepare):为**类变量**分配内存并且设置该类变量的默认初始值，即零值(**默认初始化**)。这里不包含用final修饰的static，因为final在编译的时候就会分配了，也不会为实例变量分配初始化，**类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中**。
   - 解析(Resolve):将**常量池内的符号引用转换为直接引用**的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。

5. 初始化(Initializetion):初姞化阶段就是执行**类构造器方法**< clinit >的过程，此方法不需定义，是javac编译器自动收集**类中的所有类变量的赋值动作和静态代码块中的语句**合并而来。< clinit>()不同于**类的构造器**。(关联:构造器是虚拟机视角下的< init>())·若该类具有父类，JVM会保证子类的< clinit>()执行前，父类的< clinit>()已经执行完毕，虚拟机必须保证一个类的< clinit> ()方法在多线程下被同步加锁。(同样是针对类变量，在此阶段对其进行**显示初始化**，区别类构造器和构造器)

6. 类加载器的分类：各种类加载器之间不是继承关系，**而是一种层次关系**！
   - 引导类加载器(Bootstrap ClassLoader)：用C/C++实现，嵌入在JVM内部；用于**加载Java核心类库**，如扩展类加载器、系统类加载器以及rt.jar包下的所有类；他没有父类加载器！
   - 自定义类加载器(User-defined ClassLoader)：所有**派生于抽象类ClassLoader的类加载器**都划分为自定义类加载器，具体包括扩展类加载器、系统类加载器以及用户定义的、派生于抽象类ClassLoader的加载器，前两者是虚拟机自带的类加载器，无需我们自行定义和实现。
  
7. 扩展类加载器(Extension ClassLoader)：用Java实现，上层类加载器为引导类加载器，从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。

8. 应用程序加载器(Application ClassLoader)：也叫系统类加载器(System ClassLoader)，用Java实现，上层类加载器为扩展类加载器，它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库。该类加载是程序中默认的类加载器，一般来说，**Java应用的类都是由它来完成加载**。

9. 通常使用java虚拟机提供的类加载器就能够完成正常的开发任务了，为什么要自定义类加载器？
    - 1)隔离加载类：在使用框架时，为了保证他们和我们的应用程序是不冲突的，这时我们就需要将两者进行隔离，隔离就需要我们将两者加载不同的类环境当中，所以我们需要自定义类的加载器(通常，框架会实现自己的一套类加载系统，保证自己不与应用程序所使用的包相冲突，主要针对类名，包名相同的情况)。
    - 2)修改类加载的方式：Bootstrap类加载器必然要用到，到其他的类加载器用户可以根据自己的需求，不按照Java提供的类加载方式，对特定的类进行加载。
    - 扩展加载源：除了从本地磁盘、网络等地方去加载class文件，用户还可自定义类加载器从其他地方加载class文件，如数据库中。
    - 3)防止源代码泄露：为了防止源代码泄露和篡改，在对class文件加载的过程中可以进行加密和解密操作。

10. Java虚拟机对class文件采用的是**按需加载**的方式，只有该类被使用时才会被类加载器加载到方法区并生成class对象。加载某个类的class文件时，Java虚拟机采用的是**双亲委派模式**，即把请求交由父类处理它是一种任务委派模式。


11. 双亲委派模式工作原理：宏观上看 它是一个**由下至上，再由上至下**的过程
    - 1)如果一个类加载器收到了类加载请求，它**并不会自己先去加载**，而是把这个请求委托给它上层的加载器去执行;
    - 2)如果上层加载器还存在其上层加载器，则**进一步向上委托，依次递归**,请求最终将到达**顶层的启动类加载器**;
    - 3)如果上层加载器可以完成类加载任务，**就成功返回**，倘若上层加载器无法完成此加载任务，下层加载器才会尝试自己去加载。

12. 双亲委派机制的优势：避免类的重复加载；保护程序安全，防止核心API被随意篡改，如自己定义String类。(java rt.jar中的核心类一般没有main方法)

13. 在JVM中表示两个class对象是否为**同一个类存在**两个必要条件:
   - 1)类的完整类名必须一致，包括包名。
   - 2)加载这个类的classLoader(指classLoader实例对象)必须相同。

14. 在JVM中即使这两个类对象(class对象)来源同一个class文件，被同一个虚拟机所加载，但只要加载它们的**classLoader实例对象**不同，那么这两个类对象也是不相等的。

15. JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个**类加载器的一个引用作为类型信息的一部分保存在方法区中**。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。 (一个类知道他是由哪个类加载器加载的，一个加载器也知道自己加载了哪些类，加载信息是双向存储)

16. 类的主动使用和被动使用：
    - 类的主动使用会导致类的初始化，主动使用的情况：new、静态变量访问、反射、初始化类的子类等
    - 类的被动使用不会导致类的初始化，除了主动使用的情况就是被动使用

17. 注意区分**类的初始化**和**对象的初始化**，前者是在类加载的时候发生，调用的编译层面的方法是< clint>，会在方法区中生成一个class对象；而后者是在new一个对象时发生的，调用的编译层面的方法是< int>，会在堆区中生成一个实例对象。



# **三、运行时数据区**








# **四、执行引擎**









# **五、字符串常量池**
1. 对于new String()操作，**底层创建的对象有两个**，一个是new 出来的字符串对象，另一个是 写入字符串常量池中的字符串常量对象。

2. 对于new String() + new String()操作，**底层创建的对象有五个**，依次为 StringBuilder(字符串连接符)、String & 字符串常量对象、String & 字符串常量对象。更为深入的有String(toString操作)
   
3. 对于new String()操作，首先会在**堆空间的创建一个对象**，其次会在**字符串常量池中写入一个字符串常量**(前提条件是字符串常量池中还没有该字符串)。对于向字符串常量池中写入一个字符串常量，在Java6及以前会在运行时数据区创建一个字符串常量，在Java7及以后只会在字符串常量池中创建一个字符串常量引用指向堆空间中对应的字符串对象，即该字符串常量的地址就为堆空间中对象的地址，这样做可以大大节约存储空间。至于为什么有这样的转变，是因为在Java7及以后版本，字符串常量池的存储位置由方法区移至堆空间，这样字符串常量就与实例对象同在堆空间中，使得字符串常量池中存储指向字符串对象的引用变成可能。

4. 对于new String() + new String()操作，最终只会返回两个字符串连接后的字符串对象，**并不会在字符串常量池中写入对应的字符串常量**。

5. 











# **六、垃圾回收**


















# **七、其他**

1. JVM栈中，本地变量表的基本存储单位是Slot(变量槽)，存放的数据有基本数据类型、引用数据类型和ReturnAddress类型；其中byte、short、char、boolean在存储前转换为int;float,double占两个槽位

2. byte、short、char,在生成的对应字节码并加入操作数栈时会根据数据大小选择最小的数据存储字节码指令，但在返回时统一按照int类型返回

3. 动态类型语言 & 静态类型语言：前者的数据类型是在运行时确定的，即数据的类型是根据数据本身运行时判定，代表语言为弱类型语言；后者对的数据类型是在编译时确定的，即数据的类型是根据数据的类型标识符编译时确定，代表语言为强类型语言。

4. Java方法的调用：动态链接 & 静态链接； 早起绑定 & 晚期绑定； 本质均为：符号引用 -> 直接引用

5. 局部变量是否线程安全？看具体的情况！本质上，若一个局部变量在方法内部定义且在方法内部消亡，没有被其他线程访问的机会，则该局部变量线程安全。如果局部变量以形式参数传入或返回到方法体外，能被其他线程触及到的清楚则该局部变量线程不安全。局部变量是否发生逃逸，局部变量发生逃逸，即为线程不安全的；没有发生逃逸，即为线程安全的。

6. Java语言是一种跨平台的语言，即Java语言能在各大操作系统上的JVM里面运行，而不需要考虑底层兼容问题；JVM虚拟机是一种跨语言的平台，即任何编译成符合JVM虚拟机规范的字节码文件的语言，都能在JVM上运行，如Jpthon、Kotlin、Groovy、Scala等语言

7. 程序虚拟机 & 系统虚拟机：程序虚拟机是专门为单个计算机程序设计的，底层的执行还是交给操作系统，程序虚拟机的代表为Java虚拟机；而系统虚拟机是对物理计算机的仿真，包括虚拟的CPU、内存和磁盘等，它提供了可运行操作系统的，系统虚拟机的代表为VMWare

8. 一个Java进程对应着一个JVM虚拟机实例，一个JVM虚拟机实例就对应着一个堆内存

9. 一个对象的引用出栈后，在堆中的对象实例并不会立马被回收，而是当堆空间不够时触发GC后才被垃圾回收器回收。若一个方法调用完成，对应的栈帧出栈后，该方法所涉及的实例对象立马被回收的话，由于方法的调用是十分频繁的，那么GC操作也会很频繁，从而导致用户线程需要Stop the world,最终导致系统在用户线程速度很慢，吞吐率大大降低

10. 堆空间中包含新生代&老年代，不包括永久代(JDK7及以前版本)或元数据区(JDK8及以后版本)，方法区是JVM运行时数据区的一个逻辑结构，具体的实现是永久代或元数据区。存放的信息有类型信息、域信息、方法信息以及运行时常量池。

11. -Xms：用来设置堆空间初始大小，-X为虚拟机参数；ms即memory start;-Xmx：用来设置堆空间的最大值；默认堆空间大小：初始堆空间大小为物理内存的1/64；最大堆空间大小为物理内存的1/4;

12. 在生产环境中建议将初始堆内存和最大堆内存设置相同值，避免堆空间的扩容和缩小带来的性能问题。

13. -XX:NewRatio：设置新生代与老年代的比例，默认为1:2，新生代占1，老年代占2；一般情况不会修改该比例！

14. 新生代中的Eden：S0：S1 = 8:1:1；由于自适应策略的存在，故新生代中内存比例默认为6:1:1；要想是8需要通过参数-XX:SurvivorRatio显示设置

15. MinorGC触发时机在Eden区满时，而Survivor区满时并不会触发MinorGC。当Eden区进行Minor回收时Survivor From区会一起进行垃圾回收。当Survivor区满时，特殊的处理方式是直接将该对象提升到老年区。

16. 新生代中Eden区设置过大，Survivor区的空间会变小，从而导致Survivor中存放的对象数目变少，新分配的对象会直接进入老年代。MinorGC失去意义，由于老年代中对象不断增加，会导致MajorGC的频繁出发，降低了用户线程的执行效率。

17. 新生代中Survivor区设置过大，Eden区设置过小，那么MinorGC会比较频繁的发生，从而导致用户线程执行效率低下。

18. 对象实例化过程：加载类型信息 -> 为对象分配内存 -> 处理内存分配的并发问题 -> 属性的默认初始化(零值初始化) -> 设置对象头信息(类信息、hashCode信息、GC信息) -> 显示初始化(初始化块、构造函数)

19. Java生态为什么要引入字节码这个中间的文件存储形式：对于Java语言，JVM中的执行引擎完全可以直接将Java源代码直接编译或解释成机器指令并执行。但这样做，一方面直接在源代码编译成机器指令所需的时间会比较长，另一方面，JVM虚拟机无法成为一个跨语言的平台，因为对于每一中要依托于JVM体系的语言来说，JVM必须听相应语言的编译器或解析器，这样一来，新的语言要加入并依托JVM体系的成本会比价高，基本上需要定制该语言的执行引擎，这也是引入字节码最主要的意图。有了字节码这样中间存储形式，新加入JVM体系的语言只需通过该语言的前端编译器，将该语言的源代码编译成符合JVM规范的字节码文件即可，后面的工作放心交给JVM去执行就好。这样既降低了加入Java体系的门槛，另一方面是JVM称为了真正意义上跨语言的平台，并是多语言混合式编程称为可能。

20. 注意区别：运行时常量池 & 字符串常量池 ！ 运行时常量池存储于方法区中，主要包含类信息、属性引用、方法引用以及字面量等信息；字符串常量池(字符串常量表)存储于堆区(Java7及之后)，用于存储字符串常量信息，避免重复创建具有相同字符串的对象。

21. 