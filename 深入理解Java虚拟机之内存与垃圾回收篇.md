<!-- TOC -->

- [**一、Java与JVM结构体系**](#%E4%B8%80java%E4%B8%8Ejvm%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB)
- [**二、类加载子系统**](#%E4%BA%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F)
- [**三、运行时数据区**](#%E4%B8%89%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA)
    - [**Part1 程序计数器**](#part1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8)
    - [**Part2 Java虚拟机栈&本地方法栈**](#part2-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88)
    - [**Part3 堆区**](#part3-%E5%A0%86%E5%8C%BA)
    - [**Part4 方法区**](#part4-%E6%96%B9%E6%B3%95%E5%8C%BA)
- [**四、执行引擎**](#%E5%9B%9B%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E)
- [**五、字符串常量池**](#%E4%BA%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)
- [**六、垃圾回收**](#%E5%85%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)
    - [**Part1 垃圾回收相关算法**](#part1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95)
    - [**Part2 垃圾回收相关概念**](#part2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5)
    - [**Part3 垃圾回收器**](#part3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8)
- [**七、其他**](#%E4%B8%83%E5%85%B6%E4%BB%96)

<!-- /TOC -->

# **一、Java与JVM结构体系**

1. 学习JVM的目的一方面是根据具体应用场景对JVM进行**性能调优**，另一方面是能够深入理解Java程序的执行过程，从而对运行时发生的错误能够**快速定位并处理**。

2. **内存动态分配**与**垃圾收集机制**为我们打理了很多繁琐的工作，大大提高了开发的效率。但是垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和**诊断运行时问题**的基础。

3. Java虚拟机不关心“字节码”文件是由何种语言编译过来，更不会关心运行在其内部的程序到底是使用何种编程语言编写的。**Java虚拟机拥有语言无关性**，并不会单纯地面向Java语言，只要其他编程语言能够将自己编译成符合Java虚拟机规范的字节码就行，这样Java虚拟机就会认为它是一个有效的字节码文件，从而能够被虚拟机所识别并装载运行。

4. Java平台上的**多语言混合编程**正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们**最终都运行在一个虚拟机**之上。Java虚拟机不仅是面向Java语言，它成为一个**跨语言的平台**，面向所有将自己编译成符合Java虚拟规范的字节码的语言。

5. **Java技术的核心就是Java虚拟机**，其次才是Java语言本身的语言设计。

6. 系统虚拟机 & 程序虚拟机 (无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于**虚拟机提供的资源**中)

7. JVM架构模型：
   - **基于栈的指令集架构**：设计和实现更简单;指令集更小(8位)；相同的操作需要更多的指令；不需要硬件支持；可移植性更好，更好**实现跨平台**(JVM 虚拟机采用基于栈的指令集架构)
   - **基于寄存器的指令集架构**：设计和实现更复杂;指令集更大(16位)；相同的操作需要更少的指令；需要硬件支持；可移植性较差，**更好执行性能**

8. JVM生命周期：**虚拟机的启动**(通过引导类加载器启动) -> **虚拟机的执行**(Java程序被Java虚拟机执行) -> **虚拟机的退出**(执行结束、错误或异常终止、操作系统错误等)

9. TaobaoVM：创新的**GCIH** (GC invisible heap ）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。GCIH中的对象还能够在**多个Java虚拟机进程中实现共享**。



# **二、类加载子系统**

1. ClassLoader**只负责class文件的加载**，至于它是否可以运行，则由**Execution Engine**决定。加载的类信息存放于一块称为方法区的内存空间。除了类的信息外方法区中还会存放**运行时常量池信息，可能还包括字符串字面量和数字常量**。

2. 类加载过程：加载 -> 链接(具体又细分为校验、准备、解析) - 初始化

3. 加载(Loading)：通过一个**类的全限定名**获取定义此类的**二进制字节流**并将这个字节流所代表的**静态存储结构**转化为方法区的**运行时数据结构**。类的加载是以**字节流的形式**进行的。

4. 链接(Linking)：
   - 验证(Verify):目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，**不会危害虚拟机自身安全**。主要包括文件格式验证、元数据验证、字节码验证、符号引用验证；
   - 准备(Prepare):为**类变量**分配内存并且设置该类变量的默认初始值，即零值(**默认初始化**)。这里不包含用final修饰的static，**因为final在编译的时候就会分配了**，也不会为实例变量分配初始化，**类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中**。
   - 解析(Resolve):将**常量池内的符号引用转换为直接引用**的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。

5. 初始化(Initializetion):初始化阶段就是执行**类构造器方法**< clinit >的过程，此方法不需定义，是javac编译器自动收集**类中的所有类变量的赋值动作和静态代码块中的语句**合并而来。< clinit>()不同于**类的构造器**。(关联:构造器是虚拟机视角下的< init>())；若该类具有父类，JVM会保证子类的< clinit>()执行前，父类的< clinit>()已经执行完毕，虚拟机必须保证一个类的< clinit> ()方法在多线程下被同步加锁。(同样是针对类变量，在此阶段对其进行**显示初始化**，区别**类构造器和实例构造器**)

6. 类加载器的分类：各种类加载器之间不是继承关系，**而是一种层次关系**！
   - **引导类加载器(Bootstrap ClassLoader)**：用C/C++实现，嵌入在JVM内部；用于**加载Java核心类库**，如扩展类加载器、系统类加载器以及rt.jar包下的所有类；他没有父类加载器！
   - **自定义类加载器(User-defined ClassLoader)**：所有**派生于抽象类ClassLoader的类加载器**都划分为自定义类加载器，具体包括扩展类加载器、系统类加载器以及用户定义的、派生于抽象类ClassLoader的加载器，前两者是虚拟机自带的类加载器，无需我们自行定义和实现。
  
7. 扩展类加载器(Extension ClassLoader)：用Java实现，上层类加载器为引导类加载器，从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。

8. 应用程序加载器(Application ClassLoader)：也叫系统类加载器(System ClassLoader)，用Java实现，上层类加载器为扩展类加载器，它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库。该类加载是程序中默认的类加载器，一般来说，**Java应用的类都是由它来完成加载**。

9. 通常使用java虚拟机提供的类加载器就能够完成正常的开发任务了，为什么要自定义类加载器？
    - 1)**隔离加载类**：在使用框架时，为了保证他们和我们的应用程序是不冲突的，这时我们就需要将两者进行隔离，隔离就需要我们将两者加载不同的类环境当中，所以我们需要自定义类的加载器(通常，框架会实现自己的一套类加载系统，保证自己不与应用程序所使用的包相冲突，主要针对类名，包名相同的情况)。
    - 2)**修改类加载的方式**：Bootstrap类加载器必然要用到，到其他的类加载器用户可以根据自己的需求，不按照Java提供的类加载方式，对特定的类进行加载。
    - 3)**扩展加载源**：除了从本地磁盘、网络等地方去加载class文件，用户还可自定义类加载器从其他地方加载class文件，如数据库中。
    - 4)**防止源代码泄露**：为了防止源代码泄露和篡改，在对class文件加载的过程中可以进行加密和解密操作。

10. Java虚拟机对class文件采用的是**按需加载**的方式，**只有该类被使用时才会被类加载器加载到方法区并生成class对象**。加载某个类的class文件时，Java虚拟机采用的是**双亲委派模式**，即把请求交由父类处理它是一种任务委派模式。


11. 双亲委派模式工作原理：宏观上看 它是一个**由下至上，再由上至下**的过程
    - 1)如果一个类加载器收到了类加载请求，它**并不会自己先去加载**，而是把这个请求委托给它上层的加载器去执行;
    - 2)如果上层加载器还存在其上层加载器，则**进一步向上委托，依次递归**,请求最终将到达**顶层的启动类加载器**;
    - 3)如果上层加载器可以完成类加载任务，**就成功返回**，倘若上层加载器无法完成此加载任务，下层加载器才会尝试自己去加载。

12. 双亲委派机制的优势：**避免类的重复加载**；**保护程序安全，防止核心API被随意篡改**，如自己定义String类。(java rt.jar中的核心类一般没有main方法)

13. 在JVM中表示两个class对象是否为**同一个类存在**两个必要条件:
   - 1)类的完整类名必须一致，包括包名。
   - 2)加载这个类的classLoader(指classLoader实例对象)必须相同。

14. 在JVM中即使这两个类对象(class对象)来源同一个class文件，被同一个虚拟机所加载，但只要加载它们的**classLoader实例对象**不同，那么这两个类对象也是不相等的。

15. JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个**类加载器的一个引用作为类型信息的一部分保存在方法区中**。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。 (**一个类知道他是由哪个类加载器加载的，一个加载器也知道自己加载了哪些类，加载信息是双向存储**)

16. **类的主动使用和被动使用**：
    - 类的主动使用会导致类的初始化，主动使用的情况：new、静态变量访问、反射、初始化类的子类等
    - 类的被动使用不会导致类的初始化，除了主动使用的情况就是被动使用

17. 注意区分**类的初始化**和**对象的初始化**，前者是在类加载的时候发生，调用的字节码指令层面的方法是< clint>，会在方法区中生成一个class对象；而后者是在new一个对象时发生的，调用的字节码指令层面的方法是< int>，会在堆区中生成一个实例对象。



# **三、运行时数据区**

## **Part1 程序计数器**
1. Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会**随着虚拟机启动而创建，随着虚拟机退出而销毁**(堆区、方法区)。另外一些则是与线程一一对应的，这些**与线程对应的数据区域会随着线程开始和结束而创建和销毁**(栈区、程序计数器)。运行时数据区经典模型：堆区、方法区、JVM栈、本地方法栈、程序计数器。

2. 一个JVM上运行一个Java程序，这个java程序可以开多个线程，**每个JVM中运行着唯一的运行时数据区，对应着唯一的一个RunTime实例**。因此可以通过该RunTime实例获取当前运行时数据区的相关信息。

3. 在Hotspot JVM里，**每个线程都与操作系统的本地线程直接映射**。当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。

4. JVM系统线程：虚拟机线程；周期任务线程；GC线程；编译线程；信号调度线程。

5. 程序计数器(Program Counter Register):用来存储指向**下一条字节码指令**的地址,也即将要执行的指令代码。由执行引擎读取下一条指令。运行时数据区最为简单的数据结构，只存储指令地址，没有GC行为，也不会发生ERROR。

6. 程序计数器是一块很小的内存空间，几乎可以忽略不记。也是**运行速度最快的存储区域**。在JVM规范中，每个线程都有它自己的程序计数器，**是线程私有的**，生命周期与线程的生命周期保持一致。任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址;如果是在执行native方法，则是**未指定值（undefned)** 。

7. 程序计数器是**程序控制流的指示器**，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

8. *使用PC寄存器存储字节码指令地址有什么用?* 一方面，CPU需要不停的切换各个线程，这时候切换回来以后，就得知道**线程接着该从哪开始继续执行**；另一方面，程序执行时需要通过改变PC寄存器的值来明确**下一条应该执行什么样的字节码指令**(与程序计数器的作用一致)。

9. *PC寄存器为什么会被设定为线程私有?* 在多线程的环境下，**CPU会不停地在各个线程间做任务切换**，这样必然导致经常中断或恢复，为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法是为每一个线程都分配一个pc寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互千扰的情况。

10. CPU时间片：分配各个程序或线程的**CPU执行时间**。


## **Part2 Java虚拟机栈&本地方法栈**
1. 由于跨平台性的设计，Java采用**基于栈的指令集架构**来设计的。不同平台的CPU结构不同，所以不能采用基于寄存器的指令集架构。因此，虚拟机栈&本地方法栈是运行时数据区的一个重要的数据结构。

2. Java采用基于栈的指令集架构，优点是**支持跨平台，指令集小，编译器容易实现**；缺点是**性能下降，实现同样的功能需要更多的指令**。

3. **栈是运行时的单位，而堆是对象存储的单位**。即:栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。**(栈管运行，堆管存储**)

4. Java虚拟机栈：每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，而每一个栈帧对应着一个Java方法的调用。**栈是线程私有的，其生命周期同Java线程**。

5. 栈是一种快速有效的存储方式，访问速度仅次于程序计数器。**栈帧随着方法的调用而创建并压入栈顶，随着方法执行的结束而抛出而释放所占的内存空间**，因此对于虚拟栈来说，无需进行额外的垃圾回收操作。

6. Java虚拟机规范允许Java栈的大小是**动态可变**的，也就是栈的大小可以随着程序的执行动态扩展和收缩。
    - 对于固定大小的Java虚拟机栈，如果**线程请求分配的栈容量超过Java虚拟机允许的最大容量**，Java虚拟机栈将会抛出一个StackOverflowError异常。(程序没有退出条件的递归调用，导致新的栈帧不断压入Java虚拟机栈 -Xss 设置线程分配Java虚拟机栈的最大空间)
    - 对于可变大小的Java虚拟机栈，**如果在尝试扩展的时候无法申请到足够的内存或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈**，那么Java虚拟机栈将会抛出一个OutOfMemoryError异常。(方法调用的栈帧数据较大、过多的方法调用、过多的线程启动)

7. Java虚拟机栈的单位是**栈帧(Stack Frame)**，程序中的每个方法调用都唯一对应着Java虚拟机栈中的栈帧，**栈帧是一个维系着方法执行过程中的各种数据信息的数据集**。每个栈帧主要包括**局部变量表、操作数栈、返回地址、动态链接**等信息。

8. 在一条活动的线程中，任意一个时间点只会有一个活动栈帧。即当前正在执行的方法所对应的栈帧，这个栈帧叫做**当前栈帧(Current Frame)**,当前正在执行的方法叫做当前方法(Current Method)，定义了当前方法的类就是**当前类(Current Class)**。

9. **执行引擎上执行的字节码指令只针对当前栈帧进行操作**，当前方法内若嵌套调用了另一个方法，则新的方法将成为当前方法，新创建的栈帧将成为当前栈帧。

10. 栈是线程私有的，每个线程创建时都会创建属于自己的栈区。当前方法执行结束时，当前栈帧会将执行结果传回前一个栈帧，包括指令地址和返回数据，并丢弃当前栈帧。这样可以保证方法执行完后回到调用出继续执行，而不至于程序执行出错。

11. Java的方法返回有两种，**一种是通过return指引返回**；另一种是**方法执行出错抛出异常并通过异常表返回到方法调用处**。这两种方式均会导致栈帧被弹出。

12. 栈帧中存储的主要信息有：**局部变量表(Local Variable)、操作数栈(Operand Stack)、动态链接(Dynamic Linking)、返回地址(Return Address)**

13. **局部变量表定义为数组**，主要用于存储方法参数和方法内部的局部变量，包括**基本数据类型、引用数据类型**以及returnAddress。局部变量表的底层实现是数组，因此局部变量表的大小在编译器就确定下来的，而且在程序运行期间，局部变量表的大小不会发生改变。(Maximum local variables)

14. **方法嵌套调用的次数由栈的大小决定**。一般来说，栈越大，支持方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。

15. 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后,随着方法栈帧的销毁，局部变量表也会随之销毁。

16. **局部变量表最基本的单位是Slot**，除long和double使用两个Slot外，其他的基本数据类型和引用类型均使用一个Slot存储

17. **栈帧中的局部变量表中的槽位是可以重用的**，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会**复用过期局部变量的槽位**，从而达到节省资源的目的。

18. 局部变量表中的变量也是重要的垃圾回收根节点，**只要被局部变量表中直接或间接引用的对象都不会被回收**。

19. 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-out）的操作数栈，也可以称之为**表达式栈(Expression stack)**。操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop).

20. 操作数栈，**主要用于保存计算过程的中间结果，作为计算过程中变量临时的存储空间**。栈中的任何一个元素都是可以任意的Java数据类型。32bit的类型占用一个**栈单位深度**，64bit的类型占用两个栈单位深度(使用的方式同局部变量表)。

21. 操作数栈底层是通过数组实现的，但操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈（push）和出栈(pop）操作来完成一次数据访问。**Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。**

22. 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了**栈顶缓存（Tos，Top-of-stack Cashing）技术**，**将栈顶元素全部缓在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率**。

23. 每一个栈帧内部都包含一个**指向运行时常量池中该栈帧所属方法的引用**，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。

24. **在Java源文件被编译到字节码文件中时**，所有的变量和方法引用都作为**符号引用(symbolic Reference)**保存在class文件的常量池里。比如:描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**。

25. 在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。
   - **早期绑定(静态绑定)**：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。
   - **晚期绑定(动态绑定)**：如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。

26. 非虚方法：**如果方法在编译期就确定了具体的调用版本，这个版木在运行时是不可变的**。这样的方法称为非虚方法。静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法(**即不可重写的方法，无法实现多态调用**)。其他方法称为虚方法。其他方法均为虚方法。

27. **动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期**，满足前者就是静态类型语言，反之是动态类型语言；即静态类型语言是判断变量自身的类型信息;动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。

28. **Java 语言中方法重写的本质**:
    - 1)找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。
    - 2)如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束;如果不通过，则返回java.lang.IllegalAccessError异常。
    - 3)否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
    - 4)如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

29. 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个**虚方法表**( virtual method table）(非虚方法不会出现在表中)来实现。使用索引表来代替查找。

30. 每个类中都有一个虚方法表，**表中存放着各个方法的实际入口**。这样就能避免在每次调用方法时都去向上查找对应的具体调用方法，提升了程序执行效率。
   
31. 方法退出有两种情况：**正常退出&发送未处理异常**。无论通过哪种方式退出，**在方法退出后都返回到该方法被调用的位置**。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过**异常表**来确定，栈帧中一般不会保存这部分信息。

32. 正常完成出口和异常完成出口的区别在于:**通过异常完成出口退出的不会给他的上层调用者产生任何的返回值**。

33. 一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据**方法返回值**的实际数据类型而定。在字节码指令中，返回指令包含ireturn(当返回值是boolean、byte、char.short和int类型时使用)、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。

34. 本地方法：简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法:该方法的实现由非Java语言实现，比如C/C++。Java引入本地方法的初衷是融合C/C++程序，但是现在看来，具有更为广泛而深远的意义：
    - **与Java环境外交互**:有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。包括与操作系统的交互。
    - 对于某些特定场景，如**对程序执行效率要求极高的代码块或面向专门的平台时**，可以考虑通过本地方法实现，这样可以保证程序响应时间以及更为简单的实现相应的底层操作

35. **Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用**。本地方法栈的实现和使用同Java虚拟机栈，唯一的区别只是面向的调用方法不同。

36. 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。它甚至可以直接使用本地处理器中的寄存器以及直接从本地内存的堆中分配任意数量的内存。**本质上，本地方法是在操作系统执行的一段程序，不再受虚拟机的限制**。

## **Part3 堆区**
1. **一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域**(也称GC堆)。Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，是JVM管理的最大一块内存空间。

2. 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(ThreadLocal Allocation Buffer,TLAB)，Java8后默认开启，**线程创建对象分配内存时优先从TLAB上分配**。

3. 堆在**逻辑上**可分为：新生代、老年代、永久代或元数据区(方法区的两种具体实现)

4. 通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。初始内存大小：物理内存/64；最大内存大小：物理内存/4。

5. 关于垃圾回收:**频繁收集新生区，很少收集在养老区，几乎不收集永久区/元空间**。

6. 针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：
   - **部分收集(Partial GC)**:新生代收集(Minor GC/Young GC)代表的收集器有Serial GC、Parallel Scavenger GC、ParNew等；老年代收集(Major/Old GC)代表的收集器有Serial Old GC、Parallel Scavenger Old GC、CMS等，混合收集（Mixed GC):收集整个新生代以及部分老年代的垃圾收集，代表收集器有G1等。
   - **整堆收集（Full GC)**:收集整个新生代以及部分老年代的垃圾收集。注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。

7. *为什么需要把Java堆分代?不分代就不能正常工作了吗?*其实不分代完全可以，**分代的唯一理由就是优化GC性能**。如果没有分代，那所有的对象都在一块，GC的时候要找到哪些对象没用，**这样就会对堆的所有区域进行扫描**。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来，并且GC的效率会大大提升。

8. *为什么有TLAB (Thread Local Allocation Buffer)?*
   - 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据，由于对象实例的创建在JVM中非常频繁，因此**在并发环境下从堆区中划分内存空间是线程不安全的**
   - **为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。**

9. **TLAB是在Eden区中为每个线程划分的一小块线程私有的内存块**，线程有限使用TLAB，这样能够提升程序的吞吐量以及运行性能，因此我们也将使用TLAB的内存分配方式称为快速内存分配策略。默认情况下TLAB占Eden区的**1%**。

10. 一旦对象在TLAB空间分配内存失败时，**JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。**

11. *堆是分配对象存储的唯一选择吗？*在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过**逃逸分析(Escape Analysis)**后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成**栈上分配**。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。

12. 如何发挥逃逸分析对内存分配优化的作用：**在开发过程中能使用局部变量时，不要使用成员变量！**

13. **栈上分配的根本目标是利用栈的特点，使用完的栈帧将会被抛出而自动回收掉，这样一来就无需使用专门的GC来进行对象自动回收。** 

14. 使用逃逸分析，编译器可以对代码做如下优化:
    - 1)**栈上分配**：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。
    - 2)**同步省略**：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
    - 3)**分离对象或标量替换**：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在堆内存，而是存储在栈帧中的局部变量表。**标量是指一个无法再分解成更小的数据的数据，与之相对应的是聚合量，即还可以进行分解的数据**。

15. 逃逸分析技术还不成熟，其根本原因就是**无法保证逃逸分析的性能消耗一定能低于他性能上带来的提升**。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。极端情况下，一次逃逸分析后发现没有任何非逃逸代码块，从而导致本次逃逸分析非但没有对代码的优化提供任何帮助，还花费了额外的开销去做逃逸分析。


## **Part4 方法区**
1. 《Java虚拟机规范》中明确说明:"**尽管所有的方法区在逻辑上是属于堆的一部分**，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。"，但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap (非堆)，目的就是要和堆分开。因此，**方法区在运行时数据结构上可看做是一块独立于Java堆以外的内存空间**。

2. 元空间的本质和永久代类似，**都是对JVM规范中方法区的实现**。不过元空间与永久代最大的区别在于:元空间不在虚拟机设置的内存中，而是使用本地内存。

3. 排查OOM简单思路：
    - 1、要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具(如Eclipse Memory Analyzer),也就是要先分清楚到底是出现了**内存泄漏（MemoryLeak）还是内存溢出（Memory overflow）**。
    - 2、如果是内存泄漏，可进一步通过工具查看泄漏对象到**GC Roots的引用链**。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就能准确地定位出泄漏代码的位置。
    - 3、如果不存在内存泄漏，换句话说就定内中物理内左对比看是否还可以调大，检查虚拟机的堆参数(-Xmx与-Xms)与机器物理内存对比，**检查程序中是否有某些对象生命周期过长、持有状态时间过长的情况**，尝试减少程序运行期的内存消耗。

4. 《深入理解Java虚拟机》书中对方法区(Method Area）存储内容描述如下:它用于存储已被虚拟机加载的**类型信息**、常量(**运行时常量池**)、静态变量(Java7之后移入堆区)、即时编译器编译后的**代码缓存(Code Cache)**等。

5. **常量池**是字节码文件中的主要部分，存储的是各种符号引用，运行时常量池是class文件加载到方法区后，字节码中的常量池成为方法区中的**运行时常量池**，存储的内容也由符号引用变成直接引用。

6. 常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型(字面量 & 符号引用)

7. **运行时常量池（Runtime constant Poo1）是方法区的一部分**。常量池表(Constant Pool Table）是class文件的一部分，用于存放编译期生成的各种**字面量与符号引用**，这部分内容将在类加载后存放到方法区的运行时常量池中。

8. JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。

9. 方法区演进细节：
    - JDK6及之前：有永久代(permanent generation)，**静态变量、字符串常量池存放在永久代上，且字符串常量池位于运行时常量池中**
    - JDk7：有永久代，但已经逐步“去永久代”，**字符串常量池、静态变量移除，保存在堆中**
    - JDK8及以后：**无永久代**，类型信息、字段、方法、常量保存在本地内存的元空间(MetaSpace)，但字符串常量池、静态变量仍在堆

10. *StringTable为什么要调整?* 从jdk7开始，将stringTable放到了堆空间中。因为永久代的回收效率很低，在full GC的时候才会触发。而full GC是老年代的空间不足、永久代不足时才会触发。这就导致**stringTable回收效率不高**。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。**放到堆里，能及时回收内存**。

11.  一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。方法区的垃圾收集主要回收两部分内容:**常量池中废弃的常量和不再使用的类型。**

12. 方法区内常量池之中主要存放的两大类常量:**字面量和符号引用**。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量:**1、类和接口的全限定名；2、字段的名称和描述符；3、方法的名称和描述符**

13. HotSpot虚拟机对常量池的回收策略是很明确的，**只要常量池中的常量没有被任何地方引用**，就可以被回收。回收废弃常量与回收Java堆中的对象非常类似。

14. 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要**同时满足下面三个条件**:
    - **该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。**
    - **加载该类的类加载器已经被回收**，这个条件除非是经过精心设计的可替换类加载器的场景，如oSGi、JSP的重加载等，否则通常是很难达成的。
    - **该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法**。

15. **创建对象的步骤：**
    - 1)判断对象对应的类**是否加载、链接、初始化**
    - 2)为对象分配内存：**内存规整-指针碰撞**；**内存不规则-空闲列表**
    - 3)处理并发安全问题-多个线程去抢着分配同一块内存时，需要做内存并发分配控制；为每个线程预先分配一块TLAB，为线程分配内存时**优先从分配TLAB**
    - 4)初始化分配到的空间：所有属性设默认值，保证对象实例字段在不赋值时可以直接使用
    - 5)设置对象头：包括运行时元数据-**哈希值、GC分代年龄、锁状态标志、线程持有的锁等；类型指针**-指向方法区中类型信息，确定该实例所属的类型
    - 6)执行init方法进行初始化：调用对应的构造方法

16. 对象访问的两种方式：**句柄访问**(在堆空间中开辟一块区域作为句柄池存储句柄信息，包括**对象实例数据指针和对象类型数据指针**) & **直接指针**(**实例对象中对象头中对象类型数据指针**，指向该实例对象的具体类型信息，Hotspot虚拟机采用该种方式进行对象访问)

17. **直接内存**不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。直接内存是在Java堆外的、直接向系统申请的内存区间。来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存通常，访问直接内存的速度会优于Java堆。即读写性能高。因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。**Java的NIO库允许Java程序使用直接内存，用于数据缓冲区。**

18. 由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。也可能导致OutOfMemoryError异常。**缺点：分配回收成本较高、不受JVM内存回收管理**。



# **四、执行引擎**
1. “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以**不受物理条件制约地定制指令集与执行引擎的结构体系**，能够执行那些不被硬件直接支持的指令集格式。

2. 操作系统之上，因为字节码指令并非等价于本地机器指令，它内仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。那么，如果想要让一个Java程序运行起来，**执行引擎的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以**。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。

3. **执行引擎的工作过程：**
    - 1)执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于Pc寄存器。
    - 2)每当执行完一项指令操作后，Pc寄存器就会更新下一条需要被执行的指令地址。
    - 3)当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。

4. JVM设计者们的初衷仅仅只是单纯地为了满足Java程序**实现跨平台特性**，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。

5. 代码执行分类：**解释执行 & 编译接性**
    - 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行 - 主要关注**响应速度**
    - 第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术(JIT,Just In Time)将方法编译成机器码后再执行 - 主要关注**执行效率**

6. *采用编译执行的效率很高，为什么还要保留解释执行的机制？*当程序启动后，解释器可以马上发挥作用，**省去编译的时间，立即执行**.编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。

7. 对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言(如面向用户的客户端程序)，或许就需要采用解释器与即时编译器并存的架构来换取一个**平衡点**。在此模式下，当Java虚拟器启动时，**解释器可以首先发挥作用**，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。**随着时间的推移，编译器发挥作用**，把越来越多的代码编译成本地代码，获得更高的执行效率。这也是为什么Java服务启动运行一段时间后，服务响应的速度会有所提高的主要原因。**与此同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”**。(不能因为编译器的激进优化而导致程序无法执行，因此发生激进优化时可以走解释执行的路线)

8. 当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。

9. 注意解释执行与编译执行在线上环境微妙的辩证关系。**机器在热机状态可以承受的负载要大于冷机状态**。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。

10. 热点代码及探测方式：**当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定**。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。

11. 目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为**方法调用计数器(Invocation Counter)**和**回边计数器(Back Edge Counter)**。其中，**方法调用计数器用于统计方法的调用次数，而回边计数器则用于统计循环体执行的循环次数**。HotSpot虚拟机在Client模式下是1500次；在Server模式下是10000次，判断是否为热点代码时用**方法调用计数器+回边计数器**与阈值进行比较。

12. 热度衰减：如果不做任何设置，**方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率**，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减(Counter Decay)**，而这段时间就称为此方法统计的半衰周期(Counter Half Life Time)**。热度衰减是在虚拟机进行垃圾收集时顺便进行的。

13. 缺省情况下HotSpot VM是采用**解释器与即时编译器并存的架构**，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示:
    - -Xint:完全采用解释器模式执行程序;
    - -Xcomp:完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。
    - -Xmixed:采用解释器+即时编译器的混合模式共同执行程序。(Hotspot 默认采用的代码执行方式)

14. **在HotSpot VM中内嵌有两个JIT编译器**，分别为**client Compiler和server Compiler**，但大多数情况下我们简称为c1编译器和c2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示:
    - -client:指定Java虚拟机运行在client模式下，并使用c1编译器。C1编译器会对字节码进行**简单和可靠的优化，耗时短。以达到更快的编译速度**。
    - -server:指定Java虚拟机运行在server模式下，并使用c2编译器。C2进行耗时较长的优化，以及**激进优化。但优化的代码执行效率更高**。

15. C1和C2编译器不同的优化策略:
    - c1骗译器上主要有**方法内联，去虚拟化、冗余消除**。方法内联:将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程；去虚拟化:对唯一的实现类进行内联；冗余消除:在运行期间把一些不会执行的代码折叠掉
    - C2的优化主要是在全局层面，**逃逸分析是优化的基础**。基于逃逸分析在c2上有如下几种优化:**标量替换**:用标量值代替聚合对象的属性值；**栈上分配**:对于未逃逸的对象分配对象在栈而不是堆；**同步消除**:清除同步操作，通常指synchronized。C1的优化方法均包含在C2中。

16. 所谓**AOT(Ahead Of Time Compiler)编译，是与即时编译相对立的一个概念**。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而**AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程**。

17. **AOT编译的优缺点：**
    - 优点:Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，**减少Java应用给人带来“第一次运行慢”的不良体验**。
    - 缺点:破坏了java"一次编译，到处运行”，必须为每个不同硬件、os编译对应的发行包。**降低了Java链接过程的动态性**，加载的代码在编译期就必须全部已知。



# **五、字符串常量池**
1. string实现了serializable接口:表示字符串是支持序列化的。实现了comparable接口:表示string可以比较大小。string在**jdk8及以前内部定义了final char[] value**用于存储字符串数据。**jdk9时改为byte[]**，**StringBuffer等字符串相关的类的底层实现同样也跟着改变**。

2. **字符串常量池中是不会存储相同容的字符串的。底层的实现原理如下**：
    - string的**string Pool是一个固定大小的Hashtable**，默认值大小长度是1009(JDk6及以前)。如果放进string Pool的string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string.intern时性能会大幅下降。
    - **在jdk6中stringTable是固定的，就是1009的长度**，所以如果常量池中的字符串过多就会导致效率下降很快。**在jdk7中，stringTable的长度默认值是60013**，StringTablesize设置没有要求(jdk8 后stringTable的最小长度为1009，若设置低于1009虚拟机启动时会报错)

3. Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode**字符序列**(包含同一份码点序列的常量)，并且必须是指向同一个string类实例。

4. 对于new String("java")操作，**底层创建的对象有两个**，一个是 **写入字符串常量池中的字符串常量对象**"java"(前提是字符串常量表中没有该字符串常量)。一个是 **new出来的字符串对象**(从字符串常量池中将对应的字符串常量拷贝到堆中)
   
5. 对于new String() + new String()操作，**底层创建的对象有五个**，依次为 StringBuilder(字符串连接符)、String & 字符串常量对象、String & 字符串常量对象。更为深入的有String(toString操作)

6. 对于new String()操作，首先会在**堆空间的创建一个对象**，其次会在**字符串常量池中写入一个字符串常量**(前提条件是字符串常量池中还没有该字符串)。对于向字符串常量池中写入一个字符串常量，**在Java6及以前会在方法区(永久代实现)中的字符串常量池里创建一个字符串常量，在Java7及以后只会在字符串常量池中创建一个字符串常量引用指向堆空间中对应的字符串对象，即该字符串常量的地址就为堆空间中对象的地址，这样做可以大大节约存储空间**。至于为什么有这样的转变，是因为在Java7及以后版本，字符串常量池的存储位置由方法区移至堆空间，这样字符串常量就与实例对象同在堆空间中，使得字符串常量池中存储指向字符串对象的引用变成可能。

7. 对于new String() + new String()操作(本质上是**字符串连接符两端存在字符串变量**)，最终只会返回两个字符串连接后的字符串对象，**并不会在字符串常量池中写入对应的字符串常量**。

8. 解释器:当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的**本地机器指令**执行。JIT (Just In Time Compiler)编译器:就是虚拟机将源代码直接编译成和本地机器平台相关的**机器语言**。

9. **字符串拼接操作：**
    - 1.常量与常量的拼接结果在常量池，原理是编译期优化
    - 2.字符串常量池中不会存在相同内容的常量。
    - 3.只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder
    - 4.如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此字符串在字符串常量池中的地址。

10. StringInstance.intern()总结：(**字符串拼接且带字符串变量时！！！**)
    - jdk1.6中I将这个字符串对象尝试放入串池。如果串池中有，则并不会放入。返回已有的串池中的对象的地址；如果没有，会把此**对象复制一份**，放入串池，并返回串池中的对象地址
    - Jdk1.7起，将这个字符串对象尝试放入串池。如果串池中有，则并不会放入。返回已有的串池中的对象的地址；如果没有，则会把**对象的引用地址复制一份**，放入串池，并返回串池中的引用地址(new String("hello") 与 new String("hello") + new String("world")情况不同！前者执行时会向字符串常量池中写入字符串常量，而后者不会！)



# **六、垃圾回收**

## **Part1 垃圾回收相关算法**
1. 关于垃圾收集有三个经典问题:**哪些内存需要收**(标记阶段)?**什么时候回收**?**如何回收**(清除阶段|回收阶段)?

2. 并发(Concurrent) & 并行(Parallel)区别:并发是并行的**扩展**、并行是并发的**特例**。在垃圾回收中，并行执行是指多个垃圾回收线程同时执行；并发执行是指垃圾回收线程和用户线程同时执行。

3. **强引用 - 死也不回收(OOM)； 软引用 - 不够即回收； 弱引用 - 发现即回收； 虚引用- 对象回收跟踪**

4. 什么是垃圾(Garbage)呢?**垃圾是指在运行程序中没有任何指针指向的对象**，这个对象就是需要被回收的垃圾。(An object is considered garbage when it can no longer be reached from any pointer in the running program.)

5. 为什么要进行GC？
    - 对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。
    - 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。
    - 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。

6. GC提出的目标：(性能监控&调优)
   - 自动内存管理无需开发人员手动参与内存的分配与回收，降低内存泄漏和内存溢出的风险；
   - 自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发。

7. 关于GC的一些担忧：
   - 对于Java开发人员而部自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。
   - 此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。
   - 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。

8. Java堆是垃圾回收器的主要工作区域，从回收频率上来说：**频繁收集新生代；较少收集老年代；基本不动方法区**(永久代|元数据区)

9. 在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为**垃圾标记阶段**。

10. **引用计数算法**(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性(对象头)。用于记录对象被引用的情况。
    - 缺点:它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。
    - 引用计数器有一个严重的问题，即**无法处理循环引用**的情况。这是一条致命缺陷,导致在Java的垃圾回收器中没有使用这类算法。

11. **根搜索算法**：相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。

12. 根搜索算法基本思路:
    - 可达性分析算法是以根对象集合(GC Roots，所谓"GC Roots"就是一组必须活跃的引用)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
    - 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)
    - 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。
    - 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

13. Java语言中，GC Roots元素包含以下几类：**栈 & 方法区 & 虚拟机内部 对应的引用对象**
    - 虚拟机栈中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等。
    - 本地方法栈内(通常说的本地方法)引用的对象
    - 方法区中类静态属性引用的对象：Java类的引用类型静态变量方法区中常量引用的对象
    - 字符串常量池（string Table）里的引用
    - Java虚拟机内部的引用

14. 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如:分代收集和局部回收(Partial GC)。由于Root采用栈方式存放变量和指针，**所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root**。

15. 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的**快照**中进行。这点不满足的话分析结果的准确性就无法保证(**这也是并行垃圾回收器为什么存在重新标记阶段的原因**)。这点也是导致GC进行时必须"stop the world"的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点(初始标记阶段&重新标记)时也是必须要停顿的。

16. Java语言提供了**对象终止（finalization）机制**来允许开发人员提供对象被销毁之前的自定义处理逻辑。当垃圾回收器发现没有引用指向一个对象，即:**垃圾回收此对象之前，总会先调用这个对象的finalize()方法**。finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。

17. 永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点:在finalize()时可能会导致对象复活；finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会；一个糟糕的finalize()会严重影响GC的性能。

18. 如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态如下:
    - **可触及的**:从根节点开始，可以到达这个对象。
    - **可复活的**:对象的所有引用都被释放，但是对象有可能在finalize()中复活(**对象将要被回收，但对象的finalize方法还未被执行**)。
    - **不可触及的**:对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为**finalize()只会被调用一次**。

19. 判定一个对象objA是否可回收，至少要经历两次标记过程:
    - 1．如果对象objA到 GC Roots没有引用链，则进行第一次标记。
    - 2．进行筛选，判断此对象是否有必要执行finalize()方法。如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。
    - 总的来说：finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize ()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。

20. 当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法(Mark-Sweep)、复制算法(Copying)、标记-压缩算法(Mark-Compact) 。

21. 标记–清除算法( Mark-Sweep ）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。当堆中的有效内存空间(available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world)，然后进行两项工作，第一项则是标记，第二项则是清除。
    - 标记:collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。
    - 清除:collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。

22. 标记-清除算法缺点：效率不算高在进行GC的时候，需要停止整个应用程序，导致用户体验差;这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表

23. 清除操作的本质：这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。

24. 复制(Copying)算法：将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

25. 对于复制算法：(对象复制 & 引用调整)
    - 优点:·没有标记和清除过程，实现简单，运行高效；·复制过去以后保证空间的连续性，不会出现“碎片”问题。
    - 缺点:·此算法的缺点也是很明显的，就是需要两倍的内存空间。·对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。
    - 特别的:·如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。

26. 标记-压缩算法：第一阶段和标记清除算法一样，从根节点开始标记**所有被引用对象**；第二阶段将所有的存活对象压缩到内存的一端，按顺序排放；第三阶段，清理边界外所有的空间。

27. 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-Sweep-Compact)算法。二者的本质差异在于标记-清除算法是一种**非移动式**的回收算法，标记-压缩是**移动式**的。

28. 对于标记-压缩算法：
    - 优点:消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。·消除了复制算法当中，内存减半的高额代价。
    - 缺点:从效率上来说，标记-整理算法要低于复制算法。·移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址；·移动过程中，需要全程暂停用户应用程序。即:STw

29. 总的来说，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。

30. 分代收集算法，是基于这样一个事实:不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。

31. 目前几乎所有的cc都是采用分代收集（Generational collecting)算法执行垃圾回收的。在Hotspot中，基于分代的概念，cc所使用的内存回收算法必须结合年轻代和老年代各自的特点。
    - 年轻代(Young Gen)年轻代特点:区域相对老年代较小，对象生命周期短、存活率低，回收频繁。这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。
    - 老年代(Tenured Gen)老年代特点:区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。
  
32. Mark阶段的开销与存活对象的数量成正比。Sweep阶段的开销与所管理区域的大小成正相关。Compact阶段的开销与存活对象的数据成正比。

33. 增量收集算法基本思：想如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。

34. 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记清理或复制工作。

35. 使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。(吞吐量-用户线程执行时间:系统运行的总时间)

36. 分区收集算法：一般来说，在相同条件下，堆空间越大，一次cc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。

37. 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。

## **Part2 垃圾回收相关概念**
1. 在默认情况下，通过system.gl()或者Runtime.getRuntime().gc()的调用，会显式触发Full Gc，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。然而system.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。JVM实现者可以通过system.gc ()调用来决定JVM的Gc行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。

2. 内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。由于Gc一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现ooM的情况。javadoc中对outofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。

3. Java虚拟机的堆内存不够原因有二:
    - (1)Java虚拟机的堆内存设置不够
    - (2)代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用)

4. 内存泄露也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是Gc又不能回收他们的情况，才叫内存泄漏。但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现outOfMemory异常，导致程序崩溃。

5. stop-the-world，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。为什么需要STW:
    - 可达性分析算法中枚举根节点(GC Roots）会导致所有Java执行线程停顿。
    - 分析工作必须在一个能确保一致性的快照中进行
    - 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
    - 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证

6. STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。**开发中不要用system.gc()**，会导致stop-the-world的发生。

7. 在操作系统中，是指**一个时间段**中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段(时间区间)，然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。

8. 当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程,两个进程互不抢占CPU资源，**可以同时进行**，我们称之为并行(Parallel)。其实决定并行的因素不是CPU的数量，而是cPU的核心数量，比如一个cPU多个核也可以并行。

9. 并发，指的是多个事情，在**同一时间段内同时发生**了。并行，指的是多个事情，在**同一时间点上同时发生**了。并发的多个任务之间是互相抢占CPU资源的。并行的多个任务之间是不互相抢占CPU资源的。

10. 并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下:
    - 并行(Parallel):指**多条垃圾收集线程并行**工作，但此时用户线程仍处于等待状态。如ParNew、Parallel Scavenge、Parallel old;
    - 串行（serial):相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。
    - 并发IConcurrent):指**用户线程与垃圾收集线程**同时执行（但不一定是并行的，可能会交替执行)，垃圾回收线程在执行时不会停顿用户程序的运行。

11. 程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为"安全点( safepoint)"。Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。如选择一些执行时间较长的指令作为Safe Point，像方法调用、循环执行等。

12. Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的 Safepoint。但是，程序“不执行”的时候呢?例如线程处于sleep 状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要**安全区域**(Safe Region)来解决。安全区域是指在一段代码片段中，**对象的引用关系不会发生变化**，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的safe point。

13. 1、当线程运行到safe Region的代码时，首先标识已经进入了Safe Region,如果这段时间内发生Gc，JVM会忽略标识为Safe Region状态的线程，直接将其对应的数据区进行回收，若没有标记为Safe Region的线程，JVM将继续执行这些线程，不让GC对其进行垃圾回收；2、当线程即将离开safe Region时，会检查VM是否已经完成Gc，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开safe Region的信号为止;

14. 我们希望能描述这样一类对象:当内存空间还足够时，则能保留在内存中;如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。这就要求我们提出更多种类的引用类型。

15. Java引用类型分类：
    - 强引用(StrongReference）:最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象，Java程序中99%以上都是强引用类型，也是因为强引用类型的存在，成为造成内存泄露的主要原因。- **打死也不回收**
    - 软引用(SoftReference):在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。- **空间不够才回收**
    - 弱引用(weakReference):被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。- **发现即回收**
    - 虚引用(PhantomReference):一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。- **跟踪回收对象**

16. 软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。软引用通常用来实现**内存敏感的缓存**。比如:高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就**保证了使用缓存的同时，不会耗尽内存**。java虚拟机会使软引用类型对象尽可能的保存久一些，只有迫不得已才清理。

17. 弱引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。WeakHashMap的底层实现是通过弱引用来实现的。

18. 软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。

19. 虚引用也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。为一个对象设置虚引用关联的唯一目的在于**跟踪垃圾回收过程**。比如:能在这个对象被收集器回收时收到一个系统通知。由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。


## **Part3 垃圾回收器**
1. 按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。即STW时是一个垃圾回收线程在串行工作，还是多个垃圾回收线程在并行的工作，并行垃圾回收器相比串行垃圾回收器具有更大吞吐量和更短的垃圾回收(STW)时间。

2. 按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。独占式垃圾回收器(stop the world)一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。

3. 按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片，而非压缩式的垃圾回收器不进行内存整理操作。

4. 按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。

5. 评估GC性能指标：吞吐量(Troughput)&暂停时间(Pause Time,延迟)。吞吐量:运行用户代码的时间占总运行时间的比例(总运行时间:程序的运行时间＋内存回收的时间)；暂停时间:执行垃圾收集时，程序的工作线程被暂停的时间。

6. 吞吐量优先：这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是次要考虑的，一般用于服务端程序。暂停时间优先：意味着尽可能让单次STW的时间最短，但是这也意味着GC发生的频率相比每次进行较长时间的GC来说更高，一般用于客户端交互式程序。

7. "高吞吐量"和"低暂停时间"是一对相互竞争的目标（矛盾）
    - 因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。
    - 相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。

8. 我们追求的目标是：**在保证低延迟的情况下，尽可能的提高吞吐量**，G1、ZGC就是以它作为目标的新一代垃圾收集器。

9. 主流垃圾收集器分类：
    - 串行回收器: serial、serial old
    - 并行回收器: ParNew、Parallel scavenge、Parallel old
    - 并发回收器:CMS、Gl、ZGC
    - 新生代收集器: serial、ParNew、Parallel scavenge
    - 老年代收集器: Serial old、Parallel old、CMS;
    - 整堆收集器:G1，ZGC

10. 为什么要有很多收集器，一个不够吗?因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。**没有一种放之四海皆准、任何场景下都适用的完美收集器存在**，更加没有万能的收集器。**所以我们选择的只是对具体应用最合适的收集器**。

11. Serial 收集器采用复制算法、串行回收和"stop-the-world"机制的方式执行内存回收。除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的serial old收集器。serial old收集器同样也采用了串行回收和"stop the world"机制，只不过内存回收算法使用的是标记-压缩算法。**串行回收**，简单而高效，适用于单核CPU且内存资源有限的场景。

12. 如果说serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是serial收集器的多线程版本。Par是Parallel的缩写，New:只能处理的是新生代。ParNew收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、"Stop-the-world"机制，总的来说ParNew采用**并行回收**。

13. ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量；但是在单个CPU的环境下，ParNew收集器不比serial 收集器更高效。虽然serial收集器是基于串行回收，但是由于cPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。

14. HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel scavenge收集器同样也采用了复制算法、并行回收和"Stop the world"机制。相比ParNew回收器，Parallel具有以下不同点：
    - 和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到**一个可控制的吞吐量**(Throughput)，它也被称为**吞吐圾收集器**。
    - **自适应调节策略**也是Parallel scavenge与ParNew一个重要区别。

15. Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和"stop-the-world"机制。

16. 在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器: CMS(concurrent-Mark-Sweep)收集器，这款收集器是Hotspot虚拟机中第一款真正意义上的**并发收集器**，它**第一次实现了让垃圾收集线程与用户线程同时工作**。CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（**低延迟**）就越适合与用户交互的程序，良好的响应速度能提升用户体验。CMS的垃圾收集算法采用**标记-清除**算法，并且也会"Stop-the-world".

17. CMS整个过程比之前的收集器要复杂,整个过程分为4个主要阶段，即初**始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段**。
    - 初始标记(Initial-Mark)阶段:在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是**标记出GC Roots能直接关联到的对象**。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。
    - 并发标记(Concurrent-Mark)阶段:从GC Root的**直接关联对象开始遍历对象图的过程**，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。即标记哪些对象是可达的，在垃圾回收时不做回收处理。
    - 重新标记（Remark)阶段:由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了**修正并发标记期间**，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。注意此阶段是并行的标记，需要STW，保证本次修正标记是彻底的。
    - 并发清除(Concurrent-Sweep）阶段:此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。**由于不需要移动存活对象(采用的是标记-清除算法)**，所以这个阶段也是可以与用户线程同时并发的。

18. 尽管CMS收集器采用的是并发回收（非独占式)，但是在其初始化标记和再次标记这两个阶段中仍然需要执行“stop-the-world”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-Wor1d”，只是尽可能地缩短暂停时间。由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。

19. 由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是cMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案:临时启用serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。

20. CMS收集器的垃圾收集算法采用的是**标记-清除**算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用**指针碰撞**(Bump the Pointer)技术，而只能够选择**空闲列表**（Free List）执行内存分配。

21. 既然Mark-Sweep会造成内存碎片,那么为什么不把算法换成Mark-Compact呢?因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢?要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。**Mark Compact更适合“Stop the world”这种场景下使用**

22. CMS的优点是并发收集、低延迟。CMS的弊端有以下几点:
    - 1)会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。
    - 2)CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。
    - 3)CMS收集器无法处理浮动垃圾。可能出现“concurrent Mode Failure"失败而导致另一次 Full Gc 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。

23. 关于重新标记与浮动垃圾的思考：
    - 由于标记阶段是从 GC Roots 开始标记可达对象，那么在并发标记阶段可能产生两种变动：
    - 1)本来可达的对象，变得不可达了(**浮动垃圾**)
    - 2)本来不可达的内存，变得可达了(**重新标记的对象**)
    - 第一种变动会产生所谓的浮动垃圾，第二种变动怎么回事呢？重点在于miss。如果并发标记阶段用户线程里 new 了一个对象，而它在初始标记和并发标记中是不会能够从 GC Roots 可达的，也就是were missed。如果没有重新标记阶段来将这个对象标记为可达，那么它会在清理阶段被回收，这是严重的错误，是必须要在重新标记阶段来处理的，所以这就是重新标记阶段实际上的任务。
    - 相比之下，浮动垃圾是可容忍的问题，而不是错误。那么为什么重新标记阶段不处理第一种变动呢？也许是由可达变为不可达这样的变化需要重新从 GC Roots 开始遍历，相当于再完成一次初始标记和并发标记的工作，这样不仅前两个阶段变成多余的，浪费了开销浪费，还会大大增加重新标记阶段的开销，所带来的暂停时间是追求低延迟的CMS所不能容忍的。

24. 如果你想要**最小化地使用内存和并行开销**，请选serial GC;如果你想要**最大化应用程序的吞吐量**，请选Parallel GC;如果你想要**最小化cc的中断或停顿时间**，请选CMS GC。

25. 为什么还要有G1？原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有cc就不能保证应用程序正常进行，而经常造成STw的Gc又跟不上实际的需求，所以才会不断地尝试对Gc进行优化。与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间(pause time)，同时兼顾良好的吞吐量。官方给G1设定的目标是**在延迟可控的情况下获得尽可能高的吞吐量**，所以才担当起“全功能收集器”的重任与期望，它也是第一个跨新生代与老年代的垃圾收集器。

26. G1 Gc有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的**垃圾堆积的价值大小**(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，**优先回收价值最大的Region**。由于这种方式的侧重点在于回收垃圾最大量的区间（Region)，所以我们给G1一个名字:垃圾优先(Garbage First)。

27. Gl (Garbage-First）是一款面向**服务端应用**的垃圾收集器，主要针对配备多核cPu及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。

28. 与其他 Gc收集器相比，G1使用了全新的分区算法，其特点如下所示
    - 并行与并发 - 1)并行性: G1在回收期间，可以有多个Gc线程同时工作，有效利用多核计算能力。此时用户线程sTw;2)并发性:G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况；
    - 分代收集 - 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。将堆空间分为若干个区域(Region),这些区域中包含了逻辑上的年轻代和老年代和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代;

29. G1回收器的优势-可预测的停顿时间模型：**G1跟踪各个Region里面的垃圾堆积的价值大小**（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，**优先回收价值最大的Region**。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

30. G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优:
    - 第一步:开启G1垃圾收集器
    - 第二步:设置堆的最大内存
    - 第三步:设置最大的停顿时间

31. G1中提供了三种垃圾回收模式: YoungGC、Mixed Gc和Full Gc，在不同的条件下被触发。

32. G1 GC的垃圾回收过程主要包括如下三个环节:年轻代Gc(Young GC);老年代并发标记过程(Concurrent Marking);混合回收(Mixed Gc)(如果需要，单线程、独占式、高强度的Full Gc还是继续存在的。它针对Gc的评估失败提供了一种失败保护机制，即强力回收。)

33. G1回收器垃圾回收过程
    - 应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程;61的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 Gc暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到survivor区间或者老年区间，也有可能是两个区间都会涉及。
    - 当堆内存使用达到一定值（默认45%)时，开始老年代并发标记过程。
    - 标记完成马上开始混合回收过程。对于一个混合回收期，G1 Gc从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。

34. G1回收过程Step1：年轻代GC
    - JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。
    - 年轻代垃圾回收只会回收Eden区和Survivor区。
    - 首先G1停止应用程序的执行(Stop-The-world) ，G1创建回收集(collection set)，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。

35. G1回收过程Step2：并发标记
    - 1．初始标记阶段:标记从根节点直接可达的对象。这个阶段是STw的，并且会**触发一次年轻代Gc**。
    - 2．根区域扫描(Root Region Scanning) : G1 Gc扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young Gc之前完成。主要扫描哪些老年代对象是可达的毕竟我们进行young GC的时候会移动Survivor区，移动之后就找不到哪些老年代对象是可达的了
    - 3.并发标记(Concurrent Marking):在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。
    - 4．再次标记(Remark):由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比cMS更快的初始快照算法:snapshot-at-the-beginning (SATB)原因:并发标记不准确
    - 5.独占清理(cleanup,STw):计算各个区域的存活对象和Gc回收比例，并进行排序识别可以混合回收的区域。为下阶段做铺垫。是STw的。其实是一个统计计算过程，不会涉及垃圾清理
    - 6．并发清理阶段:识别并清理完全空闲的区域。并发清理阶段任务∶如果发现区域对象中的所有对象都是垃圾，那么这个区域会被立即回收

36. G1回收过程Step3∶混合回收
    - 当越来越多的对象晋升到老年代oldregion时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器,即Mixed Gc，该算法并不是一个oldGc，除了回收整个Young Region，还会回收一部分的old Region。这里需要注意:**是一部分老年代**，而不是全部老年代。可以选择哪些oldRegion进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed Gc并不是Full Gc。

37. G1回收可选过程:Full Gc   
    - G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行(stop-The-world），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。
    - 要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full Gc呢?比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc，这种情况可以通过增大内存解决。导致G1Full Gc的原因可能有两个:
        - 1.YGC的时候没有足够的to-space来存放晋升的对象;解决︰加大堆空间
        - 2.并发处理过程完成之前空间耗尽。解决:调小触发并发GC周期的lava堆占用阈值（默认是45%，在前面参数页有)
        - 3.最大GC停顿时间太短，导致在规定的时间间隔内无法完成垃圾回收，也会导致Full GC解决:加大最大GC停顿时间

38. 怎么选择垃圾收集器?
    - 1．优先调整堆的大小让JVM自适应完成。
    - 2．如果内存小于100M，使用串行收集器
    - 3．如果是单核、单机程序，并且没有停顿时间的要求，串行收集器
    - 4．如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择
    - 5．如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器



# **七、其他**

1. JVM栈中，本地变量表的基本存储单位是Slot(变量槽)，存放的数据有基本数据类型、引用数据类型和ReturnAddress类型；其中byte、short、char、boolean在存储前转换为int;float,double占两个槽位

2. byte、short、char,在生成的对应字节码并加入操作数栈时会根据数据大小选择最小的数据存储字节码指令，但在返回时统一按照int类型返回

3. 动态类型语言 & 静态类型语言：前者的数据类型是在运行时确定的，即数据的类型是根据数据本身运行时判定，代表语言为弱类型语言；后者对的数据类型是在编译时确定的，即数据的类型是根据数据的类型标识符编译时确定，代表语言为强类型语言。

4. Java方法的调用：动态链接 & 静态链接； 早起绑定 & 晚期绑定； 本质均为：符号引用 -> 直接引用

5. 局部变量是否线程安全？看具体的情况！本质上，若一个局部变量在方法内部定义且在方法内部消亡，没有被其他线程访问的机会，则该局部变量线程安全。如果局部变量以形式参数传入或返回到方法体外，能被其他线程触及到的清楚则该局部变量线程不安全。局部变量是否发生逃逸，局部变量发生逃逸，即为线程不安全的；没有发生逃逸，即为线程安全的。

6. Java语言是一种跨平台的语言，即Java语言能在各大操作系统上的JVM里面运行，而不需要考虑底层兼容问题；JVM虚拟机是一种跨语言的平台，即任何编译成符合JVM虚拟机规范的字节码文件的语言，都能在JVM上运行，如Jpthon、Kotlin、Groovy、Scala等语言

7. 程序虚拟机 & 系统虚拟机：程序虚拟机是专门为单个计算机程序设计的，底层的执行还是交给操作系统，程序虚拟机的代表为Java虚拟机；而系统虚拟机是对物理计算机的仿真，包括虚拟的CPU、内存和磁盘等，它提供了可运行操作系统的，系统虚拟机的代表为VMWare

8. 一个Java进程对应着一个JVM虚拟机实例，一个JVM虚拟机实例就对应着一个堆内存

9. 一个对象的引用出栈后，在堆中的对象实例并不会立马被回收，而是当堆空间不够时触发GC后才被垃圾回收器回收。若一个方法调用完成，对应的栈帧出栈后，该方法所涉及的实例对象立马被回收的话，由于方法的调用是十分频繁的，那么GC操作也会很频繁，从而导致用户线程需要Stop the world,最终导致系统在用户线程速度很慢，吞吐率大大降低

10. 堆空间中包含新生代&老年代，不包括永久代(JDK7及以前版本)或元数据区(JDK8及以后版本)，方法区是JVM运行时数据区的一个逻辑结构，具体的实现是永久代或元数据区。存放的信息有类型信息、域信息、方法信息以及运行时常量池。

11. -Xms：用来设置堆空间初始大小，-X为虚拟机参数；ms即memory start;-Xmx：用来设置堆空间的最大值；默认堆空间大小：初始堆空间大小为物理内存的1/64；最大堆空间大小为物理内存的1/4;

12. 在生产环境中建议将初始堆内存和最大堆内存设置相同值，避免堆空间的扩容和缩小带来的性能问题。

13. -XX:NewRatio：设置新生代与老年代的比例，默认为1:2，新生代占1，老年代占2；一般情况不会修改该比例！

14. 新生代中的Eden：S0：S1 = 8:1:1；由于自适应策略的存在，故新生代中内存比例默认为6:1:1；要想是8需要通过参数-XX:SurvivorRatio显示设置

15. MinorGC触发时机在Eden区满时，而Survivor区满时并不会触发MinorGC。当Eden区进行Minor回收时Survivor From区会一起进行垃圾回收。当Survivor区满时，特殊的处理方式是直接将该对象提升到老年区。

16. 新生代中Eden区设置过大，Survivor区的空间会变小，从而导致Survivor中存放的对象数目变少，新分配的对象会直接进入老年代。MinorGC失去意义，由于老年代中对象不断增加，会导致MajorGC的频繁出发，降低了用户线程的执行效率。

17. 新生代中Survivor区设置过大，Eden区设置过小，那么MinorGC会比较频繁的发生，从而导致用户线程执行效率低下。

18. 对象实例化过程：加载类型信息 -> 为对象分配内存 -> 处理内存分配的并发问题 -> 属性的默认初始化(零值初始化) -> 设置对象头信息(类信息、hashCode信息、GC信息) -> 显示初始化(初始化块、构造函数)

19. Java生态为什么要引入字节码这个中间的文件存储形式：对于Java语言，JVM中的执行引擎完全可以直接将Java源代码直接编译或解释成机器指令并执行。但这样做，一方面直接在源代码编译成机器指令所需的时间会比较长，另一方面，JVM虚拟机无法成为一个跨语言的平台，因为对于每一中要依托于JVM体系的语言来说，JVM必须听相应语言的编译器或解析器，这样一来，新的语言要加入并依托JVM体系的成本会比价高，基本上需要定制该语言的执行引擎，这也是引入字节码最主要的意图。有了字节码这样中间存储形式，新加入JVM体系的语言只需通过该语言的前端编译器，将该语言的源代码编译成符合JVM规范的字节码文件即可，后面的工作放心交给JVM去执行就好。这样既降低了加入Java体系的门槛，另一方面是JVM称为了真正意义上跨语言的平台，并是多语言混合式编程称为可能。

20. 注意区别：运行时常量池 & 字符串常量池 ！ 运行时常量池存储于方法区中，主要包含类信息、属性引用、方法引用以及字面量等信息；字符串常量池(字符串常量表)存储于堆区(Java7及之后)，用于存储字符串常量信息，避免重复创建具有相同字符串的对象。

21. 对于Java新版本的变化可以从以下几个层面关注:语言层面；API层面；底层优化