<!-- TOC -->

- [**Part1：非技术部分**](#part1非技术部分)
- [**Part2：技术部分**](#part2技术部分)
- [**Part3：思考**](#part3思考)

<!-- /TOC -->


# **Part1：非技术部分** 
1. *你能对团队做出什么贡献？*   
   - 首先是工作上，我会按时的完成开发任务，保证开发质量。敢于当责，多做一点，主动地去推动开发任务和整个项目往前走。为整个团队的开发工作做出贡献；
   - 其次是学习上，我会在工作之余学习新的技术，为将来的开发工作储备技术，与此同时，也可以给团队分享自己所学技术，为整个团队的技术提升做出贡献。

2. *你认为你的个人优势是什么？*
   - 首先，我有一年的移动互联网后端开发经验，熟悉后台开发的相关业务、流程和规范；
   - 其次，我具有较好英语阅读能力与数学功底，在开发过程中能轻松阅读英文文档，以及在业务实现过程能尽可能建立数学模型，减少硬编码，提升代码执行效率；
   - 最后，我认为自己具有较强的学习能力，并且能够静下心来去完成一项有挑战的任务、去研究透一门新技术的底层原理。



# **Part2：技术部分**
1. *当你接到一个新的开发任务，你首先会做什么？*
   - 首先，分析任务的底层数据模型，并在数据库中建立好相应的数据表；
   - 其次，分析任务的业务逻辑所涉及类以及类与类之间的关系；

2. *当你遇到一个不熟悉的方法时，你会怎么做？* 
   - 查询接口说明文档
   - 更为细节的，去查看源代码

3. *Java基础面试题，改变其他方法的局部变量值的方式？*
   ```java
   public static void main(String[] args) {
        int a = 10;
        int b = 10;
        method(a,b);
        System.out.println("a="+a);
        System.out.println("b="+b);
    }

   private static void method (Integer a, Integer b) {
      /*method1:通过system.exit(0) 指令直接退出虚拟机*/
      System.out.println("a=100\nb=200");
      System.exit(0);

      /*method2:改变输出流的输出逻辑实现打印操作*/
      System.setOut( new PrintStream( System.out){ 
         @Override
         public void println(String value) {
            switch (value){
               case "a=10":
                  super.println ( "a=100" );break;
               case "b=10":
                  super.println ( "b=200" );break;
               default:
                  super.println (value) ;
         }
      }});
   }
   ```

4. *定义一个int型数组，让数组的每个位置上的值除以首位置上的元素，得到的结果，作为该位置的新值*
   ```java
      // 错误方式 - 数组第一个元素在for循环的第一次就被修改了，导致后面的数都除以1
      int[] arr = new int[]{12, 3, 3, 34, 56, 77, 432};
      for (int i = 1; i < arr.length; i++) {
         arr[i] = arr[i] / arr[0];
      }

      // 正确方式：
      int tmp = a[0];
      int[] arr = new int[]{12, 3, 3, 34, 56, 77, 432};
      for (int i = 1; i < arr.length; i++) {
         arr[i] = arr[i] / tmp;
      }
   ```


5. *为什么super(...)和this(...)调用语句不能同时在一个构造器中出现?*创建一个子类对象时，必须选创建该子类的父类对象向。这就意味着，在执行子类构造函数时，必须先执行父类构造函数。如果没有显示添加super关键字，那么编译器会为该构造函数第一句添加一个super()语句。如果有super关键字显示的调用父类构造函数，就是用指定的那个父类构造函数，否则使用默认的无参构造函数。另一种情况就是子类构造函数存在this()，调用本类其它构造函数，但是按照递归调用，最终还是会调用父类构造函数。如果一个构造函数中this()和super()都存在,那么就会出现:初始化父类两次的不安全操作，因为当super()和this()同时出现的时候，在调用完了super()之后 还会执行this()，而this()中又会自动调用super(),这就造成了调用两次super()的结果。

6.  *为什么super(...)或this(...)调用语句只能作为构造器中的第一句出现?*

7. *数组打印输出结果？*
   ```java
      char[] arr = new char[]{'a', 'b', 'c'};
      System.out.println(arr);// abc
      int[] arr1 = new int[]{1, 2, 3};
      System.out.println(arr1);// [I@5e8c92f4
      double[] arr2 = new double[]{1.1, 2.2, 3.3};
      System.out.println(arr2);// [D@61e4705b
   ```

8. *两者输出结果是否相同？分别是什么？*
   ```java
      /** 三目运算符比较基本数据类型，所以在编译阶段自动拆箱为 int 和 double 类型，由于三目运算符要求 表达式2 和 表达式3 类型一致，所以在编译阶段自动类型提升（即 int 自动类型转换为 double 类型）*/
      Object o1 = true ? new Integer(1) : new Double(2.0);
      System.out.println(o1); // 1.0

      Object o2;
      if (true) {
         o2 = new Integer(1);
      } else {
         o2 = new Double(2.0);
      }
      System.out.println(o2); // 1
   ```

9. *下面代码的输出结果是什么？能简单解释下原因吗？*
```java
      /**
      1.Integer.class在装载（Java虚拟机启动）时，其内部类型IntegerCache的static块即开始执行，实例化并暂存数值在-128到127之间的Integer类型对象。当自动装箱int型值在-128到127之间时，即直接返回IntegerCache中暂存的Integer类型对象
      2.当基本数据类型与对应的包裹类型比较时，会按照基本数据类型的值进行比较

      */
      Integer m = 1;
      Integer n = 1;
      System.out.println(m == n);  // true 引用地址相同
      Integer x = 128;
      Integer y = 128;
      System.out.println(x == y); // false 引用地址不同
```



# **Part3：思考**

1. 职业发展支持三角形：**技术、管理、沟通**；此处的管理是学会如何管理好自己，很多时候**非技术因素**比技术因素来的更加重要。

2. 