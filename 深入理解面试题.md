<!-- TOC -->

- [**一、非技术部分**](#一非技术部分)
- [**二、技术部分**](#二技术部分)
  - [Part1 Java语言](#part1-java语言)
  - [Part2 JVM相关](#part2-jvm相关)
  - [Part3 数据库相关](#part3-数据库相关)
  - [Part4 框架相关](#part4-框架相关)
  - [Part5 项目实践](#part5-项目实践)
- [**三、思考**](#三思考)

<!-- /TOC -->


# **一、非技术部分** 
1. *你能对团队做出什么贡献？*   
   - 首先是工作上，我会按时的完成开发任务，保证开发质量。敢于当责，多做一点，主动地去推动开发任务和整个项目往前走。为整个团队的开发工作做出贡献；
   - 其次是学习上，我会在工作之余学习新的技术，为将来的开发工作储备技术，与此同时，也可以给团队分享自己所学技术，为整个团队的技术提升做出贡献。

2. *你认为你的个人优势是什么？*
   - 首先，我有一年的移动互联网后端开发经验，熟悉后台开发的相关业务、流程和规范；
   - 其次，我具有较好英语阅读能力与数学功底，在开发过程中能轻松阅读英文文档，以及在业务实现过程能尽可能建立数学模型，减少硬编码，提升代码执行效率；
   - 最后，我认为自己具有较强的学习能力，并且能够静下心来去完成一项有挑战的任务、去研究透一门新技术的底层原理。



# **二、技术部分**
## Part1 Java语言
1. *Java基础面试题，改变其他方法的局部变量值的方式？*
   ```java
   public static void main(String[] args) {
        int a = 10;
        int b = 10;
        method(a,b);
        System.out.println("a="+a);
        System.out.println("b="+b);
    }

   private static void method (Integer a, Integer b) {
      /*method1:通过system.exit(0) 指令直接退出虚拟机*/
      System.out.println("a=100\nb=200");
      System.exit(0);

      /*method2:改变输出流的输出逻辑实现打印操作*/
      System.setOut( new PrintStream( System.out){ 
         @Override
         public void println(String value) {
            switch (value){
               case "a=10":
                  super.println ( "a=100" );break;
               case "b=10":
                  super.println ( "b=200" );break;
               default:
                  super.println (value) ;
         }
      }});
   }
   ```

2. *定义一个int型数组，让数组的每个位置上的值除以首位置上的元素，得到的结果，作为该位置的新值*
   ```java
      // 错误方式 - 数组第一个元素在for循环的第一次就被修改了，导致后面的数都除以1
      int[] arr = new int[]{12, 3, 3, 34, 56, 77, 432};
      for (int i = 1; i < arr.length; i++) {
         arr[i] = arr[i] / arr[0];
      }

      // 正确方式：
      int tmp = a[0];
      int[] arr = new int[]{12, 3, 3, 34, 56, 77, 432};
      for (int i = 1; i < arr.length; i++) {
         arr[i] = arr[i] / tmp;
      }
   ```

3. *为什么super(...)和this(...)调用语句不能同时在一个构造器中出现?*创建一个子类对象时，必须选创建该子类的父类对象向。这就意味着，在执行子类构造函数时，必须先执行父类构造函数。如果没有显示添加super关键字，那么编译器会为该构造函数第一句添加一个super()语句。如果有super关键字显示的调用父类构造函数，就是用指定的那个父类构造函数，否则使用默认的无参构造函数。另一种情况就是子类构造函数存在this()，调用本类其它构造函数，但是按照递归调用，最终还是会调用父类构造函数。如果一个构造函数中this()和super()都存在,那么就会出现:初始化父类两次的不安全操作，因为当super()和this()同时出现的时候，在调用完了super()之后 还会执行this()，而this()中又会自动调用super(),这就造成了调用两次super()的结果。

4.  *为什么super(...)或this(...)调用语句只能作为构造器中的第一句出现?*本质上是实例化一个子类对象前，必须先初始化该类的父类对象，super()可直接调用父类构造方法，this()调用本类中其他构造方法，而在本类中的其他构造方法体中，首句也必定是调用父类构造器。子类是从父类继承而来，继承了父类的属性和方法，如果在子类中先不完成父类的成员的初始化，则子类无法使用，应为在java中不允许调用没初始化的成员。在构造器中是顺序执行的，也就是说必须在第一行进行父类的初始化。而super能直接完成这个功能。This()通过调用本类中的其他构造器也能完成这个功能。

5. *数组打印输出结果？*
   ```java
      char[] arr = new char[]{'a', 'b', 'c'};
      System.out.println(arr);// abc
      int[] arr1 = new int[]{1, 2, 3};
      System.out.println(arr1);// [I@5e8c92f4
      double[] arr2 = new double[]{1.1, 2.2, 3.3};
      System.out.println(arr2);// [D@61e4705b
   ```

7. *两者输出结果是否相同？分别是什么？*
   ```java
      /** 三目运算符比较基本数据类型，所以在编译阶段自动拆箱为 int 和 double 类型，由于三目运算符要求 表达式2 和 表达式3 类型一致，所以在编译阶段自动类型提升（即 int 自动类型转换为 double 类型）*/
      Object o1 = true ? new Integer(1) : new Double(2.0);
      System.out.println(o1); // 1.0

      Object o2;
      if (true) {
         o2 = new Integer(1);
      } else {
         o2 = new Double(2.0);
      }
      System.out.println(o2); // 1
   ```

7. *下面代码的输出结果是什么？能简单解释下原因吗？*
```java
      /**
      1.Integer.class在装载（Java虚拟机启动）时，其内部类型IntegerCache的static块即开始执行，实例化并暂存数值在-128到127之间的Integer类型对象。当自动装箱int型值在-128到127之间时，即直接返回IntegerCache中暂存的Integer类型对象
      2.当基本数据类型与对应的包裹类型比较时，会按照基本数据类型的值进行比较

      */
      Integer m = 1;
      Integer n = 1;
      System.out.println(m == n);  // true 引用地址相同
      Integer x = 128;
      Integer y = 128;
      System.out.println(x == y); // false 引用地址不同
```


## Part2 JVM相关
1. *既然Mark-Sweep会造成内存碎片,那么为什么不把算法换成Mark-Compact呢?*因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢?要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。**Mark Compact更适合“Stop the world”这种场景下使用**，使用标记-压缩算法进行垃圾回收时，由于对堆内存活对象进行了移动，那么引用这些存活对象的指针需要同步改变，不然会导致线程运行时对存活对象的引用出错。CMS的并发清除阶段垃圾回收线程与用户线程并发运行，此时若使用标记-压缩算法将导致运行着的用户线程无法正常访问对内对象实例，故采在并发清除阶段采用标记-清除算法，**保证清除垃圾的同时，用户线程能够正常运行**。

2. *如何理解CMS收集器无法处理**浮动垃圾**？*。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。(并发标记阶段的主要任务是将初始标记阶段标记为垃圾对象的对象，在运行过程又被重新引用从而要标记为强引用对象，让其不在并发清除阶段被清除。而那些在初始标记阶段标记为非垃圾对象的对象，在运行的过程中变为垃圾对象后，重新标记阶段无法对这类垃圾对象进行重新标识，最终导致这些垃圾对象成为浮动垃圾)

3. 




## Part3 数据库相关

## Part4 框架相关

## Part5 项目实践
1. *当你接到一个新的开发任务，你首先会做什么？*
   - 首先，分析任务的底层数据模型，并在数据库中建立好相应的数据表；
   - 其次，分析任务的业务逻辑所涉及类以及类与类之间的关系；

2. *当你遇到一个不熟悉的方法时，你会怎么做？* 
   - 查询接口说明文档
   - 更为细节的，去查看源代码






# **三、思考**

1. 职业发展思考：**技术、管理、沟通**；此处的管理是学会如何管理好自己，很多时候**非技术因素**比技术因素来的更加重要。

2. 关于重新标记与浮动垃圾的思考：
    - 由于标记阶段是从 GC Roots 开始标记可达对象，那么在并发标记阶段可能产生两种变动：
    - 1)本来可达的对象，变得不可达了(**浮动垃圾**)
    - 2)本来不可达的内存，变得可达了(**重新标记的对象**)
    - 第一种变动会产生所谓的浮动垃圾，第二种变动怎么回事呢？重点在于miss。如果并发标记阶段用户线程里 new 了一个对象，而它在初始标记和并发标记中是不会能够从 GC Roots 可达的，也就是were missed。如果没有重新标记阶段来将这个对象标记为可达，那么它会在清理阶段被回收，这是严重的错误，是必须要在重新标记阶段来处理的，所以这就是重新标记阶段实际上的任务。
    - 相比之下，浮动垃圾是可容忍的问题，而不是错误。那么为什么重新标记阶段不处理第一种变动呢？也许是由可达变为不可达这样的变化需要重新从 GC Roots 开始遍历，相当于再完成一次初始标记和并发标记的工作，这样不仅前两个阶段变成多余的，浪费了开销浪费，还会大大增加重新标记阶段的开销，所带来的暂停时间是追求低延迟的CMS所不能容忍的。