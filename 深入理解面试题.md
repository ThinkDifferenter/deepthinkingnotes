<!-- TOC -->

- [**一、非技术部分**](#一非技术部分)
- [**二、技术部分**](#二技术部分)
  - [Part1 Java语言](#part1-java语言)
  - [Part2 JVM相关](#part2-jvm相关)
  - [Part3 数据库相关](#part3-数据库相关)
  - [Part4 框架相关](#part4-框架相关)
  - [Part5 项目实践](#part5-项目实践)
- [**三、思考**](#三思考)

<!-- /TOC -->


# **一、非技术部分** 
1. *你能对团队做出什么贡献？*   
   - 首先是工作上，我会按时的完成开发任务，保证开发质量。敢于当责，多做一点，主动地去推动开发任务和整个项目往前走。为整个团队的开发工作做出贡献；
   - 其次是学习上，我会在工作之余学习新的技术，为将来的开发工作储备技术，与此同时，也可以给团队分享自己所学技术，为整个团队的技术提升做出贡献。

2. *你认为你的个人优势是什么？*
   - 首先，我有一年的移动互联网后端开发经验，熟悉后台开发的相关业务、流程和规范；
   - 其次，我具有较好英语阅读能力与数学功底，在开发过程中能轻松阅读英文文档，以及在业务实现过程能尽可能建立数学模型，减少硬编码，提升代码执行效率；
   - 最后，我认为自己具有较强的学习能力，并且能够静下心来去完成一项有挑战的任务、去研究透一门新技术的底层原理。



# **二、技术部分**
## Part1 Java语言
1. *Java基础面试题，改变其他方法的局部变量值的方式？*
   ```java
   public static void main(String[] args) {
        int a = 10;
        int b = 10;
        method(a,b);
        System.out.println("a="+a);
        System.out.println("b="+b);
    }

   private static void method (Integer a, Integer b) {
      /*method1:通过system.exit(0) 指令直接退出虚拟机*/
      System.out.println("a=100\nb=200");
      System.exit(0);

      /*method2:改变输出流的输出逻辑实现打印操作*/
      System.setOut( new PrintStream( System.out){ 
         @Override
         public void println(String value) {
            switch (value){
               case "a=10":
                  super.println ( "a=100" );break;
               case "b=10":
                  super.println ( "b=200" );break;
               default:
                  super.println (value) ;
         }
      }});
   }
   ```

2. *定义一个int型数组，让数组的每个位置上的值除以首位置上的元素，得到的结果，作为该位置的新值*
   ```java
      // 错误方式 - 数组第一个元素在for循环的第一次就被修改了，导致后面的数都除以1
      int[] arr = new int[]{12, 3, 3, 34, 56, 77, 432};
      for (int i = 1; i < arr.length; i++) {
         arr[i] = arr[i] / arr[0];
      }

      // 正确方式：
      int tmp = a[0];
      int[] arr = new int[]{12, 3, 3, 34, 56, 77, 432};
      for (int i = 1; i < arr.length; i++) {
         arr[i] = arr[i] / tmp;
      }
   ```

3. *为什么super(...)和this(...)调用语句不能同时在一个构造器中出现?*
   - 创建一个子类对象时，必须选创建该子类的父类对象向。这就意味着，在执行子类构造函数时，必须先执行父类构造函数。如果没有显示添加super关键字，那么编译器会为该构造函数第一句添加一个super()语句。如果有super关键字显示的调用父类构造函数，就是用指定的那个父类构造函数，否则使用默认的无参构造函数。
   - 另一种情况就是子类构造函数存在this()，调用本类其它构造函数，但是按照递归调用，最终还是会调用父类构造函数。如果一个构造函数中this()和super()都存在,那么就会出现:初始化父类两次的不安全操作，因为当super()和this()同时出现的时候，在调用完了super()之后 还会执行this()，而this()中又会自动调用super(),这就造成了调用两次super()的结果。

4.  *为什么super(...)或this(...)调用语句只能作为构造器中的第一句出现?*
   - 本质上是实例化一个子类对象前，必须先初始化该类的父类对象，super()可直接调用父类构造方法，this()调用本类中其他构造方法，而在本类中的其他构造方法体中，首句也必定是调用父类构造器。子类是从父类继承而来，继承了父类的属性和方法，如果在子类中先不完成父类的成员的初始化，则子类无法使用，应为在java中不允许调用没初始化的成员。在构造器中是顺序执行的，也就是说必须在第一行进行父类的初始化。而super能直接完成这个功能。This()通过调用本类中的其他构造器也能完成这个功能。

5. *数组打印输出结果？*
   ```java
      char[] arr = new char[]{'a', 'b', 'c'};
      System.out.println(arr);// abc
      int[] arr1 = new int[]{1, 2, 3};
      System.out.println(arr1);// [I@5e8c92f4
      double[] arr2 = new double[]{1.1, 2.2, 3.3};
      System.out.println(arr2);// [D@61e4705b
   ```

6. *两者输出结果是否相同？分别是什么？*
   ```java
      /** 三目运算符比较基本数据类型，所以在编译阶段自动拆箱为 int 和 double 类型，由于三目运算符要求 表达式2 和 表达式3 类型一致，所以在编译阶段自动类型提升（即 int 自动类型转换为 double 类型）*/
      Object o1 = true ? new Integer(1) : new Double(2.0);
      System.out.println(o1); // 1.0

      Object o2;
      if (true) {
         o2 = new Integer(1);
      } else {
         o2 = new Double(2.0);
      }
      System.out.println(o2); // 1
   ```

7. *下面代码的输出结果是什么？能简单解释下原因吗？*
```java
      /**
      1.Integer.class在装载（Java虚拟机启动）时，其内部类型IntegerCache的static块即开始执行，实例化并暂存数值在-128到127之间的Integer类型对象。当自动装箱int型值在-128到127之间时，即直接返回IntegerCache中暂存的Integer类型对象
      2.当基本数据类型与对应的包裹类型比较时，会按照基本数据类型的值进行比较

      */
      Integer m = 1;
      Integer n = 1;
      System.out.println(m == n);  // true 引用地址相同
      Integer x = 128;
      Integer y = 128;
      System.out.println(x == y); // false 引用地址不同
```

8. *Comparable和Comparator的区别？*
   - Comparable可以认为是一个自然比较器，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的。至于具体如何比较，看该类是如何重写compareTo方法的。如将该类的对象添加到集合中，进行与比较相关的操作时(如排序)，compareTo方法会被自动调用，并返回一个int类型数据指示比较的结果。(1表示大于被比较的对象、0为等于、-1为小于)。Comparable接口定义的compareTo方法如下：
   ```java
         // 传入的参数为被比较的对象
         int compareTo(T o);
   ```
   - Comparator可以认为是一个定制比较器，如果实现类没有实现Comparable接口，又想对两个类进行比较；或者实现类实现了Comparable接口，但是对compareTo方法内的比较算法不满意(这意味着同时实现两者时，会以Comparator的比较方法为准)。那么可以实现Comparator接口，自定义一个比较器，在compare方法实现比较的具体算法。实际开发中，有两种使用场景，一种为创建一个比较器并实现Comparator接口，这种类的命名一般为***Comparator，然后再比较器中实现具体的比较方法；另一种是以匿名类的形式作为参数直接传给一个与比较操作相关的方法或流，如Collections.sort()&stream().sort()，告诉那些方法如何进行比较。Comparator声明为函数式接口，在流中与比较相关的操作中广泛使用。Comparator接口定义的compare()方法如下：
   ```java
         // 传入的参数为两个要比较的对象
         int compare(T o1, T o2);
   ```
   - 实现Comparable接口的方式比实现Comparator接口的耦合性要强一些，如果要修改比较算法，要修改Comparable接口的实现类，而实现Comparator的类是在外部进行比较的，不需要对实现类有任何修 改。从这个角度说，其实有些不太好，尤其在我们将实现类的.class文件打成一个.jar文件提供给开发者使用的时候。实际上实现Comparator 接口的方式后面会写到就是一种典型的策略模式。两者没有好坏之分，需要根据具体比较场景选用不同的实现方式。

9. 


## Part2 JVM相关
1. *既然Mark-Sweep会造成内存碎片,那么为什么不把算法换成Mark-Compact呢?*
   - 因为当**并发清除**的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢?要保证用户线程能继续执行，前提的它运行的资源不受影响。**Mark Compact更适合“Stop the world”这种场景下使用**，使用标记-压缩算法进行垃圾回收时，由于对堆内存活对象进行了移动，那么引用这些存活对象的指针需要同步改变，不然会导致线程运行时对存活对象的引用出错。
   - CMS的并发清除阶段垃圾回收线程与用户线程并发运行，此时若使用标记-压缩算法，对象实例在内存中位置会改变，这将导致运行着的用户线程无法正常访问对内对象实例，故采在并发清除阶段采用标记-清除算法，**保证清除垃圾的同时，用户线程能够正常运行**。

2. *如何理解CMS收集器无法处理**浮动垃圾**？*。
   - 在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交替运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。(并发标记阶段的主要任务是将初始标记阶段标记为垃圾对象的对象，在运行过程又被重新引用从而要标记为强引用对象，让其不在并发清除阶段被清除。而那些在初始标记阶段标记为非垃圾对象的对象，在运行的过程中变为垃圾对象后，重新标记阶段无法对这类垃圾对象进行重新标识，最终导致这些垃圾对象成为浮动垃圾)




## Part3 数据库相关

## Part4 框架相关

## Part5 项目实践
1. *当你接到一个新的开发任务，你首先会做什么？*
   - 首先，分析任务的底层数据模型，并在数据库中建立好相应的数据表；
   - 其次，分析任务的业务逻辑所涉及类以及类与类之间的关系；

2. *当你遇到一个不熟悉的方法时，你会怎么做？* 
   - 查询接口说明文档
   - 更为细节的，去查看源代码






# **三、思考**

1. 职业发展思考：**技术、管理、沟通**；此处的管理是学会如何管理好自己，很多时候**非技术因素**比技术因素来的更加重要。

2. 关于重新标记与浮动垃圾的思考：
    - 由于标记阶段是从 GC Roots 开始标记可达对象，那么在并发标记阶段可能产生两种变动：
    - 1)本来可达的对象，变得不可达了(**浮动垃圾**)
    - 2)本来不可达的内存，变得可达了(**重新标记的对象**)
    - 第一种变动会产生所谓的浮动垃圾，第二种变动怎么回事呢？重点在于miss。如果并发标记阶段用户线程里 new 了一个对象，而它在初始标记和并发标记中是不会能够从 GC Roots 可达的，也就是were missed。如果没有重新标记阶段来将这个对象标记为可达，那么它会在清理阶段被回收，这是严重的错误，是必须要在重新标记阶段来处理的，所以这就是重新标记阶段实际上的任务。
    - 相比之下，浮动垃圾是可容忍的问题，而不是错误。那么为什么重新标记阶段不处理第一种变动呢？也许是由可达变为不可达这样的变化需要重新从 GC Roots 开始遍历，相当于再完成一次初始标记和并发标记的工作，这样不仅前两个阶段变成多余的，浪费了开销浪费，还会大大增加重新标记阶段的开销，所带来的暂停时间是追求低延迟的CMS所不能容忍的。