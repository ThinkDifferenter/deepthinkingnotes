<!-- TOC -->

- [**一、面向对象设计思想**](#一面向对象设计思想)
- [**二、异常处理**](#二异常处理)
- [**三、数组**](#三数组)
- [**四、常用类**](#四常用类)
- [**五、容器**](#五容器)
- [**六、I/O流**](#六io流)
- [**七、多线程**](#七多线程)
- [**八、网络**](#八网络)
- [**九、其他**](#九其他)

<!-- /TOC -->

# **一、面向对象设计思想**

1. 面向对象程序设计重要思想：**让合适的方法出现在合适类中**！遇到问题时**首先考虑该问题所涉及的类和对象**、类中所具有的属性和方法以及**类和对象与对象间的关系**，而不应该考虑怎么一步一步的完成完成任务！

2. **类是对象的抽象，对象是类的实例**，即Java中的每个类都对应现实对象的抽象！

3. **继承关系是一般与特殊的关系**；**聚合关系是整体和部分的关系**（聚集->松耦合 & 组合->紧耦合）；**实现关系是类对接口方法不同的解析**

4. 结构化程序设计的复用只能在**方法层面**的复用，而面向对象程序设计的复用可以在**对象层面**的复用； ->  **编程追求目标：可复用 & 可扩展**

5. 成员变量可以为基本类型和引用类型，且在编译时会进行初始化，具体在类加载阶段进行初始化(静态变量，对于实例变量在调用实例构造方法进行初始化)。**局部变量不会自动进行初始化**，故使用时需手动初始化

6. **方法重载的前提是编译器能够区分调用具体的方法**，方法的重载能使类的接口的使用更加方便，使用更加舒适

7. this:对那个对象调的方法，this就指该对象的引用！**this 是当前对象自身引用，super是当前对象的父类引用**

8. static修饰的变量被所有的实例对象共享，尽管这个实例对象指向null！ 

9. 变量分类：局部变量 & 成员变量(类变量/静态变量 & 实例变量)  方法分类：实例方法 & 类方法

10. 所有未加package的类称为**裸体类**，很容易发生引用冲突

11. 访问修饰符作用域大小：private、default(package)、protect、public.**注意protect访问修饰符在同一包内的均可访问，不只是继承关系才能访问**

12. 子类继承父类时，父类私有的对象同样继承下来了，只是在子类中没有访问权限，**但是继承下来了**！！！（对私有属性和方法，**子类具有所有权，但没有使用权**）

13. **重写方法不能比被重写方法有更严格的访问权限**，方法重写动机：**子类对从父类继承的方法不满意，需要重新定义**

14. 对象实例化中，给对象的属性赋值的操作：**默认初始化**(类加载过程中的的链接阶段) -> **显式初始化/初始化块**(类加载过程中的初始化阶段) -> **构造函数初始化**(类的构造方法)

15. 如果在子类构造方法中调用super方法，**必须在子类构造方法第一行调用super**；若没有显式调用父类构造方法，系统将会去调用父类没有参数的构造方法，若父类没有无参的构造方法，则调用默认构造方法。

16. 创建子类对象前，**需要将其所有父类加载到方法区，并调用相应的构造方法将该类的所有父类的实例对象创建好**。子类对象由父类对象扩展而来，故子类对象中包含父类对象，创建子类对象前先创建根父类Object的对象，**由上至下依次创建，最终将该子类对象**。

17. **父类可以指向之类对象，但不能访问子类新增的属性和方法！**

18. 多态的三个条件：**要有继承；要有重写；要有父类引用指向子类对象**。Java程序的多态是通过**动态绑定机制**实现，当一个方法的参数为基类对象，Java会根据运行时传入的子类对象调用子类重写该父类具体的方法，从而实现多态。

19. 抽象方法，抽象类：只有定义，没有实现的必要，**用于被子类继承和方法重写**。含有抽象方法的类表明该类是**残缺不全的**，即没有足够的信息支持定义一个完整的类的对象，**故含有抽象方法的类必为抽象类**。**故抽象方法必须被重写，抽象类必须被继承**；若一个类继承了抽象类但不知道抽象类中抽象方法的具体实现，**可以将抽象类中抽象方法继续声明为abstract**。

20. 本质上，**接口是特殊的抽象类**，**一般定义为某种能力**，当类实现接口时，表明该类获得了该接口声明的能力(**接口以able结尾，说明接口定义一种能力**)。抽象类中所有的方法都是抽象方法，且所有属性均为**public static final**(默认是且只能是，修正了C++多继承的属性重名的问题)。接口中所有方法均为abstract，无需显示声明。

21. 用接口去引用实现接口的实例对象，**该引用只能访问接口中定义的方法和属性**。**对于该类定义的其他方法，该引用是无法感知的**。

22. **Java 语言中方法重写的本质**:
    - 1)找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。
    - 2)如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束;如果不通过，则返回java.lang.IllegalAccessError异常。
    - 3)否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
    - 4)如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

23. 使用this关键字：
    - 1.在任意方法或构造器内，如果使用当前类的**成员变量或成员方法**(包括构造方法)可以在其前面添加this,增强程序的阅读性。不过，通常我们都习惯省略this。
    - 2.当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量
    - 3.使用this访问属性和方法时，如果**在本类中未找到，会从父类中查找**
    - 4.this可以作为一个类中**构造器相互调用**的特殊格式(通过this调用的其他构造方法必须放到该构造器的第一句，super也还是如此)

24. 继承的作用:
    - 继承的出现减少了代码冗余，提高了代码的复用性。
    - 继承的出现，更有利于功能的扩展。
    - 继承的出现让类与类之间产生了关系，提供了**多态的前提**(有继承、有重写、有父类引用指向子类对象)。
    - 注意:**不要仅为了获取其他类中某个功能而去继承**！

25. 方法重写的要求:
    - 1．子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表
    - 2．子类重写的方法的**返回值类型不能大于父类被重写的方法的返回值类型**
    - 3．子类重写的方法使用的**访问权限不能小于父类被重写的方法的访问权限**，子类不能重写父类中声明为private权限的方法
    - 4．子类方法**抛出的异常不能大于父类被重写方法的异常**
    - 注意:子类与父类中**同名同参数的方法必须同时声明为非static的**(即为重写)，或者**同时声明为static的**(不是重写)。因为static方法是属于类的，子类无法覆盖父类的方法

26. **重写&重载本质区别**：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；而对于重写，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。

27. 对Java对象的强制类型转换称为造型：
    - 从子类到父类的类型转换可以自动进行
    - 从父类到子类的类型转换必须通过造型(强制类型转换)实现
    - **无继承关系的引用类型间的转换是非法的**
    - 在造型前可以使用instanceof操作符测试一个对象的类型

28. 重写equals()方法的原则：
    - **对称性**:如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。
    - **自反性**: x.equals(x)必须返回是“true”。
    - **传递性**:如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”,那么z.equals(x)也应该返回是“true”。
    - **一致性**:如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。
    - 注意：任何情况下，**x.equals(null)，永远返回是“false”;x.equals(和x不同类型的对象)永远返回是“false”**。

29. 类变量作为该类各个对象之间共享的变量。在设计类时,**分析哪些字段或方法不因对象的不同而改变**，将这些字段设置为类变量。相应的方法设置为类方法，如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。如果想让一个类的所有实例共享数据，就用类变量！

30. **类方法内部不能有this&super调用，因为类方法无需实例就能对其就行访问**；另static方法不能被重写，静态方法是静态绑定的，即在编译时就确定了该调用哪个类的哪个静态方法，不存在多态性。

31. **静态代码块:用static修饰的代码块**
    - 1.可以有输出语句。
    - 2.可以对类的属性、类的声明进行初始化操作。
    - 3.不可以对非静态的属性初始化。即:不可以调用非静态的属性和方法。
    - 4.若有多个静态的代码块，那么按照从上到下的顺序依次执行
    - 5.静态代码块的执行要先于非静态代码块。
    - 6.**静态代码块随着类的加载而加载，且只执行一次**(类加载系统中的初始化阶段)。

32.  **非静态代码块:没有static修饰的代码块**
    - 1.可以有输出语句。
    - 2.可以对类的属性、类的声明进行初始化操作。
    - 3.除了调用非静态的结构外，还可以调用静态的变量或方法。
    - 4.若有多个非静态的代码块，那么按照从上到下的顺序依次执行。
    - 5.**每次创建对象的时候，都会执行一次。且先于构造器执行。**

33. **程序中成员变量赋值的执行顺序**：声明成员变量的默认初始化 -> 显式初始化、多个初始化块依次被执行(同级别下按先后顺序执行) -> 构造器再对成员进行初始化操作 -> 通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值。

34. final修饰符总结：**对于基本类型，不可变指的是值；对于引用类型，不可变指的是引用地址。**

35. 抽象类体现的就是一种**模板模式**的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。**当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现**。换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。

36. 对于接口，一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。**有了接口，就可以得到多重继承的效果**。另一方面，有时必须从**几个类中抽取出一些共同的行为特征**，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。

37. 接口就是规范，定义的是一组规则，体现了现实世界中“**如果你是/要...则必须能...**”的思想。**继承是一个"是不是"的关系，而接口实现则是"能不能"的关系**。接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守。

38. 接口中的默认方法：
    - 若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法(不管此方法是否是默认方法)，在实现类同时实现了这两个接口时，会出现:接口冲突。解决办法:实现类必须覆盖接口中同名同参数的方法，来解决冲突。
    - 若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。因为此时遵守:**类优先原则**。接口中具有相同名称和参数的默认方法会被忽略。

39. 接口中可定义静态方法，该方法不能被实现，可通过接口名.静态方法调用。接口本质上为特殊的类，只包含静态常量与抽象方法的类(java8增加默认实现)。

40. 当一个事物的内部，还有一个部分需要一个完整的结构进行描述,而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。注意：Inner class的名字不能与包含它的外部类类名相同;

41. 分类:**成员内部类(static成员内部类和非static成员内部类)；局部内部类（不谈修饰符)；匿名内部类**

42. 成员内部类作为**类的成员的角色**:
    - 和外部类不同，Inner class还可以声明为private或protected;
    - 可以调用外部类的结构
    - lnner class可以声明为static的，但此时就不能再使用外层类的非static的成员变量;

43. 成员内部类作为**类的角色**:
    - 可以在内部定义属性、方法、构造器等结构
    - 可以声明为abstract类，因此可以被其它的内部类继承
    - 可以声明为final的
    - 编译以后生成OuterClass$InnerClass.class字节码文件(也适用于局部内部类)

44. 成员内部类使用注意：
    - 1．**非static的成员内部类中的成员不能声明为static的**，只有在外部类或static的成员内部类中才可声明static成员。
    - 2．外部类访问成员内部类的成员，需要“内部类.成员"或“内部类对象.成员”的方式
    - 3．成员内部类可以直接使用外部类的所有成员，包括私有的数据
    - 4．当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的

45. 局部内部类的特点
    - 内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。
    - 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。(局部内部类在方法或代码块中定义)
    - 局部内部类可以使用外部类的成员，包括私有的。**局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周期不同所致。**
    - **局部内部类和局部变量地位类似**，不能使用public,protected,缺省,private
    - **局部内部类不能使用static修饰，因此也不能包含静态成员**

46. 匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。**一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类**。常见的使用场景为 Thread t1 = new Thread(new Runable(){ // 实现run()方法})



# **二、异常处理**

1. 当程序发生异常，**如果有捕获异常的代码块，则按照捕获异常的逻辑处理异常**；**若没有捕获异常的代码块，则程序将发生的异常抛出到上层调用处**，如此反复处理，若整个代码中没有处理异常的代码块，程序所发生的异常最终会被Java虚拟机捕获并处理，处理方式为 输出异常信息(printStackTrace()方法)

2. catch块中声明的异常型参，**在代码捕获到异常时，系统会自动创建一个对应异常类的对象并传入catch块中**，并在catch块中执行相应的异常处理逻辑。

3. **Throwable(Error & Exception(RuntimeException & OtherException) )**RuntimeException没有必要显式捕捉(在程序运行过程中经常发生，捕捉起来比较麻烦)，除此之外的Exception均需显式捕捉。(检查异常 & 非检查异常)

4. finally块中通常执行方法执行的善后工作，如资源的清除工作。注意：**关闭资源的操作同样容易抛出异常，所以需要在finally块中关闭资源时同样做try-catch操作，Java8 后提出try-with-resource 语句，避免了以往在finally中写嵌套的try-catch块。**

5. catch块中一定要对捕捉的异常进行处理，至少将捕获的异常信息打印出来。**不能将异常"吞掉"**！**任何的异常如果不想自己处理，可以在方法声明时throws相关异常**，main方法同样可以声明throws相关异常，并且java运行时系统可以捕捉并打印异常信息，但这是一种很不良好的编程习惯！

6. **自己能够处理的异常，一定要自己处理；自己不能处理的异常，一定要将异常抛出。绝不能将异常"吞掉"**

7. throw new SomeException; method() throws SomeException; **throw 用于在方法内部显式地抛出异常，而throws 用于声明方可能抛出的异常**。二者有本质区别！

8. 声明抛异常时，**需要精细化抛出，尽管所抛异常具有继承的关系！这是一种良好的编程习惯！**

9. 常见异常：OutOfMemoryError；StackOverFlowError；IndexOutOfBoundException；IOException；FileNotFoundException；NullPointerException；ArithmeticException；IllegalMonitorStateException

10. RuntimeException类或是它的子类异常的特点是:即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过(但运行时会发生异常使得程序运行终止)。如果抛出的异常是IOException等类型的非运行时异常，则必须捕获，否则编译错误。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常。(**检查异常&非检查异常**)



# **三、数组**

1. int[] arr = new int[5]; **数组是引用类型并在堆中分配内存**。(阿里Java开发规范建议，数组符号靠近类型即int[] ,而不推荐int a[])

2. 数组初始化：**动态初始化**(先为数组分配空间，在对数组中每个位置进行赋值) & **静态初始化**(为数组分配空间的同时进行赋值操作) & **默认初始化**(只为数组分配空间但不做赋值操作，Java会为数组每个位置进行默认初始化)；

3. length是数组对象的**属性**，故访问时采用数组对象array.length的方式。String中的length是String类中的**方法**，故获取当前字符串对象长度时需StringObject.length()

4. 数组一般作为连续的存储空间存在，数组复制时无需在一个一个的复制拷贝，而是将**整段数据直接进行拷贝**，System中ArrayCopy就是采用整段数据拷贝的方式，最快！

5. 二维数组的第一维装的是指向第二维数组的指针，分析清楚**内存结构**！



# **四、常用类**

1. String 不可变字符串，StringBuilder&StringBuffer 可变字符串；StringBuilder & StringBuffer 区别：**前者线程不安全，后者线程安全**。这也导致在单线程的环境下，StringBuilder 比 StringBuffer来的快。(字符串连接符+,在Java5及之前版本中使用StringBuffer实现，在后期使用的是StringBuilder实现)

2. File只代表某个文件或路径名，至于是目录还是文件可以通过isDirectory()方法判断。**new 出File 对象时只是在堆中创建一个File对象，在真实的物理盘上不会生成对应的文件或者文件夹**。

3. 注解本质上是代码里的特殊标记，这标记可以在编译、类加载、运行时被读取，通过反射机制获取注解信息后并执行相应的处理。**自定义的注解必须配上注解的信息处理流程才有意义**。注解的使用是大趋势，**框架 = 注解 + 反射 + 设计模式**。

4. 注释中定义的元素称为成员，没有成员的注解称为标记。熟悉两个元注解@Retention & @Target。

5. 



# **五、容器**

1. **容器类就是装其他各种对象的类**，具有增、删、改、查等操作的特点。

2. 为什么用容器所实现的接口去引用具体的容器类对象：**增加程序的灵活性**！**当你决定不使用现有的数据结构时，只需修改容器类，程序的其他部分无需做任何修改！**

3. 为什么容器中只能存放引用类型：与Java语言的发展历史有关，**在泛型没有提出之前，所有的容器盛放的都是Object类**，这就要就我们在编码时需要很清楚自己向容器中添加的数据类型并在操作前做强制类型转换，故从容器一开始就设计为存放引用类型。泛型的提出只是让编译器在程序编译时就对放入容器的类做类型检查，且无需我们手动做强制类型装换，提升的程序的可读性和健壮性。

4. **重写equals方法时，必须重写hashCode方法**，**保证两个对象euqals为true时，两对象的hashCode值一定相等**。重写hashCode方法时，不用自己动手实现，可以选用Java已经实现hashCode方法的字段作为自己重写hashCode方法的一种选择，当然也可以自己设计一套哈希算法。hashCode值在使用键值对方式的数据结构中和从堆中快速取对象时用到。

5. iterator迭代器提供一种所有集合类通用的遍历方式，不论是List、Set还是Map，也不论是数组实现、链表实现还是哈希实现。迭代器实际的涉及的三个方法是 **hasNext()、next()、remove()**。并且在使用iterator遍历集合时，**集合处于锁定状态**，集合对象本身无法对自己进行添加和删除操作(**只能看不能改**)。而iterator自己的remove()方法可以对集合元素进行删除。hasNext()指向要访问对象的左侧，next()做指针移动操作并返回移动后指针左侧的元素。remove()方法移除访问指针左侧的元素。

6. 增强for循环不能通过下标直接访问数据，以及删除对应位置的元素，**底层是通过iterator迭代器**来实现集合的遍历。简单遍历时可以使用，其他情况不建议使用。

7. **equals()方法在容器中进行添加(针对Set)、删除、查找等涉及判断是否相等的操作中会用到**，故自定义了类并添加到容器中，需要重写equals()方法，让容器类中相关方法能够正确的工作。**hashCode()在容器中涉及键值对方式存储的数据结构时需要用到**，主要针对HashMap&Hashtable&HashSet，若自定义了并添加到这些数据结构的容器中时，必须重写hashCode()方法，一方面保证定义的数据结构不被破坏，另一方保证容器类提供的方法能够正常工作。

8. **compareTo()方法在对容器元素进行排序等涉及元素间比较的操作时会用到**，使用集合框架提供的排序算法时，集合中的对象没有实现Compareable接口并重写compareTo()方法，排序算法不知如何比较元素间的大小，更谈不上对集合中的所有元素进行排序操作。

9. 通过接口传入参数, 可以**隐藏实现该接口类的其他信息**，也就是说，在方法中只能使用该接口定义的属性和方法，对于接口实现类的其他方法，该接口引用无法访问。 

10. 泛型的引入相比使用Object最直接的影响是在对象操作之前，**不需要做强制类型转换**。其次，程序的可读性和稳定性会更好，**程序在编译器会对容器中的类型做检查，避免了类型不明确的问题**。
    
11. HashSet的无序性是指添加元素的顺序并不是最终存储元素的顺序(**添加元素的无序性**)，因为HashSet中的元素存储位置是通过元素的Hash值来确定的。LinkedHashSet在数据存储时同样是无序的，LinkedHashSet在HashSet存储结构的基础上，**每个数据结点多了两个指针域，用于每个数据结点存储时的先后顺序**。List的有序性就是指添加元素的顺序即为元素最终存储的顺序。

12. TreeSet添加元素时：自然排序中(实现Comparable接口)，**比较两个对象是否相同的标准为: compareTo()返回0**.不再是equals()；定制排序中(创建Comparator接口的实现类)，**比较两个对象是否相同的标准为: compare()返回0**.不再是equals()。(TreeSet底层是按照元素的大小进行构建的红黑树)

13. 迭代器提供一种遍历容器的方式，而又无需**暴露容器中对象的内部细节**。Iterator接口中声明了三个抽象方法，hasNext();next();remove(); (理解迭代器的运行方式)




# **六、I/O流**
1. 流的分类：按**数据流的方向**可分为输入流(InputStream & Reader)与输出流(OutPutStream & Writer)；按**处理数据单位**可分为字节流(InputStream & OutputStream 以Stream结尾的流)与字符流(Reader & Writer 或以这两者结尾的流)；按**功能**可分为节点流和处理流(节点流为对数据做原始的传输，处理流对结点流数据进行筛选、包装等操作)

2. Serializable接口是一个**标记性接口**，其中没有任何方法的声明。实现该接口的类会被**编译器**视为可序列化的类，具体的序列化方式由Java语言本身来确定。Externalizable 继承于 Serializable接口，实现该接口的类同样具有序列化能力，不过具体序列化的方式由用户自己定义。


# **七、多线程**
1. 将一个实现Runnable接口的对象交给一个Thread并调用start()方法去执行，**本质上是开了一个线程去执行重写的run()方法逻辑**，该线程与主线程或调用线程**并发执行**。而通过实现Runnable接口的对象去直接调用run()方法，只是普通的**方法嵌套调用**，本质上不会开一个线程，**与主线程或调用线程并发的执行run()方法的逻辑**。区别：**方法调用和线程启动**！

2. 能通过实现Runnable接口的方式并交给Thread对象执行的方式创建新的线程，就不用直接继承Thread类，这样能提高程序的**灵活性和可扩展性**

3. **Thread.sleep()在哪个线程中调用，哪个线程就睡眠**。不要轻易调Thread的interrupt()，不要使用Thread的stop()。**不要在catch块中做业务逻辑操作，这是一个不好的编程方式。**

4. join() 谁调用就将谁合并到主线程或调用线程中去，将该线程变成与**普通方法嵌套调用**的一样的执行方式，即该**线程的逻辑执行完后再执行主线程或调用线程**的逻辑，

5. 线程设置较高的优先级在多线程的环境下运行相对能够获得较多的时间片去执行该线程的逻辑，**但无法保证绝对的执行时间**。

6. **同样一个实现Runnable接口的类的实例对象**(线程对象)，可以交给不同线程执行。线程自然结束的标志是线程对象中run()方法执行完毕。(线程也可以非自然结束，如调用stop()、interrupt())

7. synchronize 关键字加在方法上代表该方法被线程执行时具有该方法所在**类或类的对象的锁**(实例方法对应实例对象的锁、静态方法对应类的锁)，而不是该方法的锁！方法不具有锁，具有锁的只有类和类的实例对象。**加锁的粒度尽可能的小**，这样可以提高程序运行的效率。拿着相应的锁去锁定相应的代码块，在运行的过程中，**只有锁定的代码允许获得相应锁的线程运行，而没有锁定代码块，可以同时被多个线程运行，不论是类锁还是对象锁**。

8. 对于一个临界资源，我们需要考虑访问该临界资源的**所有方法是否能够做到互斥访问**，若存在不互斥访问的方法，在多线程的环境下，临界资源同样也会访问出错。

9. 在实例对象的方法中调用this.wait()，本质上是调用Object类的wait()方法，其含义为 **当前访问本对象的线程wait()**！调用this.wait() 的前提是**访问该对象的线程获得了该对象的锁**，这样才有资格wait()。**也就是调用this.wait()的方法必须是synchronized的**！(否则报 IllegalMonitorStateException 异常)

10. 在实例对象的方法中调用this.wait()，**当前访问本对象的线程会释放该线程所持有的锁**！这点与Thread.sleep()的方法有本质区别,**在线程中执行Thread.sleep()方法，线程不会释放手中所持有的锁，并且在sleep指定时间后转为就绪态，获得时间片后继续执行**。而this.wait()方法执行后，**线程如果没有被唤醒的话将永久休眠**，如被唤醒，则需重新获得类或对象锁后才能继续执行线程相关逻辑。

11. 在实例对象的方法中调用this.notify(),唤醒一个在本对象wait着的线程。若该对象上没有wait着的线程，notify方法没有任何作用效果。notifyAll()用于唤醒所有在本对象wait着的线程。注意:**线程不能自己唤醒自己，线程也不能让其他线程等待！**

12. 在多线程环境下，判断条件是否成立并做带有潜在异常操作时，**不要使用if，而要使用while**! 因为使用if当条件满足时进入的方法块(如执行wait操作)中发生异常并被catch到，if后的代码仍然会被执行，很显然，代码没有按照我们所设计的方式执行而发生错误。使用while就能有效避免这个问题，即使while块中的代码出现异常被catch到，执行catch代码块后同样会回来做设定条件的判断，直到while条件不满足或while块中的逻辑被正确执行为止。

13. **线程的简单理解：一个程序中不同的执行路径！**(方法嵌套调用 & 多线程执行 两者的程序运行图)

14. 比较Thread&Runnable两种线程创建方式-开发中优先选择实现Runnable接口，因为实现Runnable接口的方式**更为灵活**。具体表现为：一方面，**没有类单继承的局限性，不会影响类原有的继承关系**；另一方面，在处理**多个线程共享数据的场景**中，实现Runnable接口的方式能够天然的支持。(从宏观理解上来看，让一个具有多个线程执行的能力，应该实现Runnable接口而非继承Thread类)

15. 任何一个对象都可作为对象监视器(锁)，但需要**注意多个线程是否共用同一把锁！**只有这样才能保证多个线程在执行代码块时任意时刻只有一个在执行。

16. 多线程程序的优点:
    - 1.提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
    - 2.提高计算机系统CPU的利用率
    - 3.改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改

17. Java的调度方法：同优先级线程组成先进先出**队列**（先到先服务），使用时间片策略；对高优先级，使用优先调度的**抢占式策略**

18. Java中的线程分为两类:一种是守护线程，一种是用户线程。它们在几乎每个方面都是相同的，**唯一的区别是判断JVM何时离开，若JVM中都是守护线程，当前JVM将退出**。守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。Java垃圾回收就是一个典型的守护线程。

19. Java线程生命周期：(状态的转换以及对应方法的调用)
    - **新建**:当一个Thread类或其子类的对象被创建时，线程处于新建状态(即new了一个Thread)
    - **就绪**:处于新建状态的线程被start()后，将进入线程队列等付CPU时间片，此时的线程具备了运行的条件，只是没分配到CPU资源(start()方法,yield(),失去CPU资源)
    - **运行**:当就绪的线程被调度并获得CPU资源时,便进入运行状态，run()定义了线程的操作和功能(得到CPU资源)
    - **阻塞**:在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态(sleep(),wait(),join(),等待同步锁)
    - **死亡**:线程完成了它的全部工作或线程被提前强制性地(stop()方法)中止或出现异常导致结束(stop(),线程运行出现异常)

20. 实例对象监视器&类对象监视器：前者用于非静态方法的同步，后者用于静态方法的同步。本质上需要满足：**多个线程共用同一个监视器**，这样才能保证临界资源或临界代码块在任何时刻都只被这些线程中的一个线程执行。

21. 使用多线程前先明确执行的代码是否涉及**临界资源(共享资源)**，若存在则存在线程安全问题，我们需要通过同步机制，保证任何时刻只有一个线程在执行与临界资源相关的临界代码块。不过需要注意，**同步代码块的范围不能过大也不能过小**，过大会导致程序执行效率低下，不能很好的发挥多线程的优势；过小则会导致无法保证临界代码块的线程安全。

22. **释放锁的相关操作：**
    - 当前线程的同步方法、同步代码块执行结束。
    - 当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。
    - 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。
    - 当前线程在同步代码块、同步方法中执行了线程**对象的wait()方法**，当前线程暂停，并释放锁。

23. **不会释放锁的操作：**
    - 线程执行同步代码块或同步方法时，程序调用**Thread.sleep()、Thread.yield()方法暂停当前线程的执行**(区别于wait()方法)
    - 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁(同步监视器)。(应尽量避免使用suspend()和resume()来控制线程，声明弃用)

24. 线程间通信方式：wait()与notify()和notifyAll()：
    - wait():令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。(调用wait()方法的线程会释放该线程所持有的锁，不同于Thread.sleep()方法，sleep()可以理解为睡眠，wait()方法可以理解为休眠)
    - notify():唤醒正在排队等待同步资源的线程中优先级最高者结束等待
    - notifyAll():唤醒正在排队等待资源的所有线程结束等待.
    - 说明：三种方法均属于Object类，作用的对象均为当前执行在本对象上的线程，且**三种方法均需在synchronize方法或代码块中**，不然会报lllegalMonitorStateException异常(多次执行线程的start()方法也报同样的异常)，原因是这三种操作都与线程所持有的锁相关，因此非synchronize方法和代码块没有资格执行三种方法。

25. 使用Lock处理同步问题时，由于没有使用synchronize修饰符，线程间的通信方式不能再使用wait()、notify()等方法。这时可以用属于该lock的条件对象Condition来实现线程间的通信，对应的方法为await()与signal()。

26. 对于多个线程共享的临界资源，可以使用Java现成的实现BlockingQueue来存放，BlockingQueue接口中的put()和take()方法能够保证多个线程在操作临界资源时线程安全。两个方法内部是通过lock和condition来实现线程同步和通信的


# **八、网络**

1. 网络中两个节点能够相互通讯，就像两个人能够相互沟通。**两个人若能相互沟通，则他们使用的是相同的语言；网络上的两个节点能够相互通信，则他们使用的是相同的通讯协议**。

2. **通信协议分层思想的好处**:①开发过工作会更加容易，无需在实现底层的具体细节；②对于资源的分配更加灵活，若某一层实现的资源不够时，可以只针对那一层的资源进行扩展，这样更具有针对性和灵活性。分层的思想在开发的场景中应用比较广泛，是一种较好的程序设计思想。

3. TCP/IP 模型(也是实际应用时所分的层次)由底至上分为：物理层、网络层(IP层)、传输层(TCP/UDP层)、应用层(我们所编写的层)。**可以看出我们开发过程中与传输层打交道，即考虑使用TCP还是UDP协议对数据数据进行传输**。

4. IP地址分为两个部分：**网络地址+物理地址**。对于IPv4来说，IP中的网络地址占第一个字节为A类网，占前两个字节为B类网，占前三个字节为C类网。不同的网络类型，意味着在此网段下的物理机的数量最多能够分配多少台。不过可以采用内网机制，一台机器作为访问外网的路由器，内网中的所有物理机可通过该具有路由功能的机器访问外网，不过内网所有机器对外的IP是一样的，均为那台与外网相连并具有路由功能的机器。(该机器会具有两块网卡，一块连接公网，另一块连接内网所有机器)

5. TCP传输协议具有**可靠性**，**首先需要传输数据的双方建立起连接；其次在每次传输数据包时均需确认收到**。UDP传输协议是一种**不可靠**的数据传输协议，**首先传输数据的双方不需建立起连接；其次数据的发送方无需知道数据的接收方是否收到数据包，数据的接收方也不会向数据的发送方回复说数据已收到**。前者可靠但数据传输比较慢，后者则相反。

6. **端口号用于区分同一台机器上不同的应用程序**，即同一台机器上的不同应用程序和服务可以通过不同的端口号来分别访问。自己变成程序一般用1024以上的端口号，1024以下的系统可能会占用。端口号类型又可分为TCP和UDP端口。

7. Socket编程中，服务端ServerSocket需指定服务的端口号，启动时会**阻塞式**的监听该端口号并等待客户端的接入。对于客户端Socket需要指定服务端的IP地址和端口号，至于自己使用什么端口号来访问服务端，有系统自行分配决定。



# **九、其他**

1. Java变量分类：局部变量 & 成员变量；其中成员变量又可分为 静态变量(类变量) & 实例变量)

2. 数组为空，不代表数组没有创建；**数组一旦创建，其长度就是确定的**

3. 多态的使用前提：**类的继承关系；方法的重写；父类引用指向子类对象**。

4. **静态方法不能被重写**！**父类、子类可具有同名的静态方法，但不是重写**！

5. 何为线程安全：1.**如果只有一个线程才可以操作此数据，则必是线程安全的**；2.如果有多个线程操作此数据，则此数据是共享数据，如不考虑同步机制的话，会存在线程安全问题

6. 静态初始化块(类的初始化，即类在加载到内存时所执行的代码块，而每个类只被加载一次，静态代码块只会被执行一次)；初始化块(每个类的对象创建时均会执行的代码块)；构造函数(类的特定对象创建时执行的代码块)

7. **类的初始化**，即在类加载阶段中的初始化操作，对应的虚拟机层面的方法为 **clinit**;**类对象的初始化**，即在方法中创建类的对象并在堆中分配实例内存时的操作，对应的虚拟机层面的方法为 **init**

8. Java方法分类：实例方法 & 类方法

9. String str = "Hello";// 字面量定义  String str = new String("Hello");// 对象创建定义。其中，以字面量形式定义的字符串会自动添加到字符串常量池中，而用new的方式创建字符串对象会在堆中分配内存(堆中处字符串常量池以外的区域)存储该字符串对象，因此不会添加到字符串常量池中。如需将该字符串对象存储的字符串动态添加到字符串常量池，调用intern()方法即可。

10. **String的底层实现由Java8及以前的char数组编程Java8以后的byte数组**。而数组在编译时长度就确定了，故字符串是一个不可变的对象

11. String的intern()方法:在程序运行时，向字符串常量池(字符串常量表StringTable)中动态添加字符串常量。如果字符串常量池中没有添加的字符串，则在常量池中添加新的字符串常量，若字符串常量池中存在要添加的字符串，则不再重新添加，复用已有字符串即可，判断要添加的字符串常量是否存在，是通过Hashtable的哈希算法来判断。Java6及之前的Hashtable长度为1009，Java7之后的Hashtable长度为60013，Hashtable长度的增加可以降低字符串常量添加时的哈希冲突，提高判断字符串是否存在的效率。

12. **intern()方法的执行过程：**先通过hashcode判断要添加的字符串是否存在于字符串常量池，若存在则返回该字符串在常量池中的地址。若不存在，则在字符串常量池中分配内存存储该字符串。

13. Java在做字符串拼接操作时，若"+"号左右有变量存(非final)在，则底层会创建StringBuilder对象并调用append()方法做字符串的链接操作。**说明：在Java5之前使用的是StringBuffer对象来做字符串的连接操作，该类线程安全，但性能较低，故更换为StringBuilder**。若字符串拼接操作的两端均为字符串常量或字符串常量的引用(final修饰的字符串)，则使用编译期优化，底层实现同字符串常量的连接操作。建议：在定义各种量时，能够使用final时建议加上final!

14. 字符串连接操作的两种方式:① 采用字符串连接操作符的形式 ② 采用StringBuilder对象并调用append()方法的方式；**相比之下，前者每次做连接操作时需要创建一个StringBuilder对象和调用toString()方法时，需要创建String对象**。一方面在需要做大量连接操作的场景中，每次连接操作创建对象需要花费一定时间，另一方面，创建的对象会占用堆空间的内存并在进行垃圾回收时需要花费一定时间。对于使用StringBuilder对象并调用append()方法的方式，不论做多少次字符串的连接操作，始终只有一个StringBuilder对象存在，可以优化的点在于创建StringBuilder对象时可以根据具体业务需求指定StringBuilder的大小，减少StringBuilder对象频繁扩容所带来的额外开销。

15. 创建字符串常量并添加到字符串常量池方式：①通过字面量的方式定义字符串 String str = "java"; ②通过 ***.intern()的方式向常量池中动态添加字符串常量，具体形式如 String str = new String("java").intern() | new StringBuilder("java").toString().intern()。

16. 在调用intern()方法前，**先考虑字符串常量池中是否已经存在该字符串常量**，如存在intern方法只返回该字符串在字符串常量池中地址。
