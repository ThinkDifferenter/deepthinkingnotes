# **一、面向对象设计思想**

1. 面向对象程序设计重要思想：让合适的方法出现在合适类中！遇到问题时首先考虑该问题所涉及的类和对象、类中所具有的属性和方法以及类和对象与对象间的关系，而不应该考虑怎么一步一步的完成完成任务！

2. 类是对象的抽象，对象是类的实例，即Java中的每个类都对应现实对象的抽象！

3. 继承关系是一般与特殊的关系；聚合关系是整体和部分的关系（聚集->松耦合 & 组合->紧耦合）；实现关系是类对接口方法不同的解析

4. 结构化程序设计的复用只能在方法层面的复用，而面向对象程序设计的复用可以在对象层面的复用； ->  编程追求目标：可复用 & 可扩展

5. 成员变量可以为基本类型和引用类型，且在编译时会进行初始化，具体在类加载阶段进行初始化。局部变量不会自动进行初始化，故使用时需手动初始化

6. 方法重载的前提是编译器能够区分调用具体的方法，方法的重载能使类的接口的使用更加方便，使用更加舒适

7. this:对那个对象调的方法，this就指该对象的引用！this 是当前对象引用，super是当前对象的父类引用

8. static修饰的变量被所有的实例对象共享

9. 变量分类：局部变量 & 成员变量(类变量/静态变量 & 实例变量)  方法分类：实例方法 & 类方法

10. 所有未加package的类称为裸体类，很容易发生引用冲突

11. 访问修饰符作用域大小：private、defaul(package)t、protect、public.注意protect访问修饰符在同一包内的均可访问，不只是继承关系才能访问

12. 子类继承父类时，父类私有的对象同样继承下来了，只是在子类中没有访问权限，但是继承下来的！！！（对私有属性和方法，子类具有所有权，但没有使用权）

13. 重写方法不能比被重写方法有更严格的访问权限，子类对从父类继承的方法不满意，需要重新定义

14. 对象实例化中，给对象的属性赋值的操作：属性的默认初始化 -> 显示初始化/初始化块 -> 构造函数初始化

15. 如果在子类构造方法中调用super方法，必须在子类构造方法第一行调用super;若没有显式调用父类构造方法，系统将会去调用父类没有参数的构造方法，若父类没有无参的构造方法，则调用默认构造方法。

16. 创建子类对象前，需要将其所有父类加载到方法区，并调用相应的构造方法将该类的所有父类的实例对象创建好。子类对象由父类对象扩展而来，故子类对象中包含父类对象，创建子类对象前先创建根父类Object的对象，由上至下依次创建，最终将该子类对象。

17. 父类可以指向之类对象，但不能访问子类新增的属性和方法！

18. 多态的三个条件：要有继承；要有重写；要有父类引用指向子类对象。Java程序的多态是通过动态绑定机制实现，当一个方法的参数为基类对象，Java会根据运行时传入的子类对象调用子类重写该父类具体的方法，从而实现多态。

19. 抽象方法，抽象类：只有定义，没有实现的必要，用于被子类继承和方法重写。含有抽象方法的类表明该类是残缺不全的，即没有足够的信息支持定义一个完整的类的对象，故含有抽象方法的类必为抽象类。故抽象方法必须被重写，抽象类必须被继承；若一个类继承了抽象类但不知道抽象类中抽象方法的具体实现，可以将抽象类中抽象方法继续声明为abstract。

20. 本质上，接口是特殊的抽象类，一般定义为某种能力，当类实现接口时，表明该类获得了该接口声明的能力(接口以able结尾，说明接口定义一种能力)。抽象类中所有的方法都是抽象方法，且所有属性均为public static final(默认是且只能是，修正了C++多继承的属性重名的问题)。接口中所有方法均为abstract，无需显示声明。

21. 用接口去引用实现接口的实例对象，该引用只能访问接口中定义的方法和属性。对于该类定义的其他方法，该引用是无法感知的。



# **二、异常处理**

1. 当程序发生异常，如果有捕获异常的代码块，则按照捕获异常的逻辑处理异常；若没有捕获异常的代码块，则程序将发生的异常抛出到上层调用处，如此反复处理，若整个代码中没有处理异常的代码块，程序所发生的异常最终会被Java虚拟机捕获并处理，处理方式为 输出异常信息(printStackTrace()方法)

2. catch块中声明的异常型参，在代码捕获到异常时，系统会自动创建一个对应异常类的对象并传入catch块中，并在catch块中执行相应的异常处理逻辑。

3. Throwable(Error & Exception(RuntimeException & OtherException) )RuntimeException没有必要显式捕捉(在程序运行过程中经常发生，捕捉起来比较麻烦)，除此之外的Exception均需显式捕捉。(检查异常 & 非检查异常)

4. finally块中通常执行方法执行的善后工作，如资源的清除工作。注意：关闭资源的操作同样容易抛出异常，所以需要在finally块中关闭资源时同样做try-catch操作，Java8 后提出try-with-resource 语句，避免了以往在finally中写嵌套的try-catch块。

5. catch块中一定要对捕捉的异常进行处理，至少将捕获的异常信息打印出来。不能将异常"吞掉"！任何的异常如果不想自己处理，可以在方法声明时throws相关异常，main方法同样可以声明throws相关异常，并且java运行时系统可以捕捉并打印异常信息，但这是一种很不良好的编程习惯！

6. 自己能够处理的异常，一定要自己处理；自己不能处理的异常，一定要将异常抛出。决不能将异常"吞掉"

7. throw new SomeException; method() throws SomeException; throw 用于在方法内部显式地抛出异常，而throws 用于声明方可能抛出的异常。二者有本质区别！

8. 声明抛异常时，需要精细化抛出，尽管所抛异常具有继承的关系！这是一种良好的编程习惯！

9. 常见异常：OutOfMemoryError；StackOverFlowError；IndexOutOfBoundException；IOException；FileNotFoundException；SQLException ；NullPointerException



# **三、数组**

1. int[] arr = new int[5]; 数组是引用类型并在堆中分配内存。(阿里Java开发规范建议，数组符号靠近类型即int[] ,而不推荐int a[])

2. 数组初始化：动态初始化(先为数组分配空间，在对数组中每个位置进行赋值) & 静态初始化(为数组分配空间的同时进行赋值操作) & 默认初始化(只为数组分配空间但不做赋值操作，Java会为数组每个位置进行默认初始化)；

3. length是数组对象的属性，故访问时采用数组对象.length的方式。String中的length是String类中的方法，故获取当前字符串对象长度时需StringObject.length()

4. 数组一般作为连续的存储空间存在，故在数组复制时无需在一个一个的复制拷贝，而是将整段数据直接进行拷贝，System中ArrayCopy就是采用整段数据拷贝的方式，最快！

5. 二维数组的第一维装的是指向第二维数组的指针，分析清楚**内存结构**！



# **四、常用类**

1. String 不可变字符串，StringBuilder&StringBuffer 可变字符串；StringBuilder&StringBuffer 区别：前者线程不安全，后者线程安全。这也导致在单线程的环境下，StringBuilder 比 StringBuffer来的快。

2. File只代表某个文件或路径名，至于是目录还是文件可以通过isDirectory()方法判断。new 出File 对象时只是在堆中创建一个File对象，在真实的物理盘上不会生成对应的文件或者文件夹。

3. 