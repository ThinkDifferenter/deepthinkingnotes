# **一、面向对象设计思想**

1. 面向对象程序设计重要思想：让合适的方法出现在合适类中！遇到问题时首先考虑该问题所涉及的类和对象、类中所具有的属性和方法以及类和对象与对象间的关系，而不应该考虑怎么一步一步的完成完成任务！(首先对底层数据模型设计，设计好了数据模型，就知道了问题所涉及的类，包括

2. 类是对象的抽象，对象是类的实例，即Java中的每个类都对应现实对象的抽象！

3. 继承关系是一般与特殊的关系；聚合关系是整体和部分的关系（聚集->松耦合 & 组合->紧耦合）；实现关系是类对接口方法不同的解析

4. 结构化程序设计的复用只能在方法层面的复用，而面向对象程序设计的复用可以在对象层面的复用； ->  编程追求目标：可复用 & 可扩展

5. 成员变量可以为基本类型和引用类型，且在编译时会进行初始化，具体在类加载阶段进行初始化。局部变量不会自动进行初始化，故使用时需手动初始化

6. 方法重载的前提是编译器能够区分调用具体的方法，方法的重载能使类的接口的使用更加方便，使用更加舒适

7. this:对那个对象调的方法，this就指该对象的引用！this 是当前对象引用，super是当前对象的父类引用

8. static修饰的变量被所有的实例对象共享

9. 变量分类：局部变量 & 成员变量(类变量/静态变量 & 实例变量)  方法分类：实例方法 & 类方法

10. 所有未加package的类称为裸体类，很容易发生引用冲突

11. 访问修饰符作用域大小：private、defaul(package)t、protect、public.注意protect访问修饰符在同一包内的均可访问，不只是继承关系才能访问

12. 子类继承父类时，父类私有的对象同样继承下来了，只是在子类中没有访问权限，但是继承下来的！！！（对私有属性和方法，子类具有所有权，但没有使用权）

13. 重写方法不能比被重写方法有更严格的访问权限，子类对从父类继承的方法不满意，需要重新定义

14. 对象实例化中，给对象的属性赋值的操作：属性的默认初始化 -> 显示初始化/初始化块 -> 构造函数初始化

15. 如果在子类构造方法中调用super方法，必须在子类构造方法第一行调用super;若没有显式调用父类构造方法，系统将会去调用父类没有参数的构造方法，若父类没有无参的构造方法，则调用默认构造方法。

16. 创建子类对象前，需要将其所有父类加载到方法区，并调用相应的构造方法将该类的所有父类的实例对象创建好。子类对象由父类对象扩展而来，故子类对象中包含父类对象，创建子类对象前先创建根父类Object的对象，由上至下依次创建，最终将该子类对象。

17. 父类可以指向之类对象，但不能访问子类新增的属性和方法！

18. 多态的三个条件：要有继承；要有重写；要有父类引用指向子类对象。Java程序的多态是通过动态绑定机制实现，当一个方法的参数为基类对象，Java会根据运行时传入的子类对象调用子类重写该父类具体的方法，从而实现多态。

19. 抽象方法，抽象类：只有定义，没有实现的必要，用于被子类继承和方法重写。含有抽象方法的类表明该类是残缺不全的，即没有足够的信息支持定义一个完整的类的对象，故含有抽象方法的类必为抽象类。故抽象方法必须被重写，抽象类必须被继承；若一个类继承了抽象类但不知道抽象类中抽象方法的具体实现，可以将抽象类中抽象方法继续声明为abstract。

20. 本质上，接口是特殊的抽象类，一般定义为某种能力，当类实现接口时，表明该类获得了该接口声明的能力(接口以able结尾，说明接口定义一种能力)。抽象类中所有的方法都是抽象方法，且所有属性均为public static final(默认是且只能是，修正了C++多继承的属性重名的问题)。接口中所有方法均为abstract，无需显示声明。

21. 用接口去引用实现接口的实例对象，该引用只能访问接口中定义的方法和属性。对于该类定义的其他方法，该引用是无法感知的。



# **二、异常处理**

1. 当程序发生异常，如果有捕获异常的代码块，则按照捕获异常的逻辑处理异常；若没有捕获异常的代码块，则程序将发生的异常抛出到上层调用处，如此反复处理，若整个代码中没有处理异常的代码块，程序所发生的异常最终会被Java虚拟机捕获并处理，处理方式为 输出异常信息(printStackTrace()方法)

2. catch块中声明的异常型参，在代码捕获到异常时，系统会自动创建一个对应异常类的对象并传入catch块中，并在catch块中执行相应的异常处理逻辑。

3. Throwable(Error & Exception(RuntimeException & OtherException) )RuntimeException没有必要显式捕捉(在程序运行过程中经常发生，捕捉起来比较麻烦)，除此之外的Exception均需显式捕捉。(检查异常 & 非检查异常)

4. finally块中通常执行方法执行的善后工作，如资源的清除工作。注意：关闭资源的操作同样容易抛出异常，所以需要在finally块中关闭资源时同样做try-catch操作，Java8 后提出try-with-resource 语句，避免了以往在finally中写嵌套的try-catch块。

5. catch块中一定要对捕捉的异常进行处理，至少将捕获的异常信息打印出来。不能将异常"吞掉"！任何的异常如果不想自己处理，可以在方法声明时throws相关异常，main方法同样可以声明throws相关异常，并且java运行时系统可以捕捉并打印异常信息，但这是一种很不良好的编程习惯！

6. 自己能够处理的异常，一定要自己处理；自己不能处理的异常，一定要将异常抛出。决不能将异常"吞掉"

7. throw new SomeException; method() throws SomeException; throw 用于在方法内部显式地抛出异常，而throws 用于声明方可能抛出的异常。二者有本质区别！

8. 声明抛异常时，需要精细化抛出，尽管所抛异常具有继承的关系！这是一种良好的编程习惯！

9. 常见异常：OutOfMemoryError；StackOverFlowError；IndexOutOfBoundException；IOException；FileNotFoundException；SQLException ；NullPointerException



# **三、数组**

1. int[] arr = new int[5]; 数组是引用类型并在堆中分配内存。(阿里Java开发规范建议，数组符号靠近类型即int[] ,而不推荐int a[])

2. 数组初始化：动态初始化(先为数组分配空间，在对数组中每个位置进行赋值) & 静态初始化(为数组分配空间的同时进行赋值操作) & 默认初始化(只为数组分配空间但不做赋值操作，Java会为数组每个位置进行默认初始化)；

3. length是数组对象的属性，故访问时采用数组对象array.length的方式。String中的length是String类中的方法，故获取当前字符串对象长度时需StringObject.length()

4. 数组一般作为连续的存储空间存在，故在数组复制时无需在一个一个的复制拷贝，而是将整段数据直接进行拷贝，System中ArrayCopy就是采用整段数据拷贝的方式，最快！

5. 二维数组的第一维装的是指向第二维数组的指针，分析清楚**内存结构**！



# **四、常用类**

1. String 不可变字符串，StringBuilder&StringBuffer 可变字符串；StringBuilder&StringBuffer 区别：前者线程不安全，后者线程安全。这也导致在单线程的环境下，StringBuilder 比 StringBuffer来的快。

2. File只代表某个文件或路径名，至于是目录还是文件可以通过isDirectory()方法判断。new 出File 对象时只是在堆中创建一个File对象，在真实的物理盘上不会生成对应的文件或者文件夹。



# **五、容器**

1. 容器类就是装其他各种对象的类

2. 为什么用容器所实现的接口去引用具体的容器类对象：增加程序的灵活性！当你决定不使用现有的数据结构时，只需修改容器类，程序的其他部分无需做任何修改！

3. 为什么容器中只能存放引用类型：基础数据类型都存放在栈帧中的局部变量表中，随着方法的执行，栈帧中的数据会被回收而丢失

4. 重写equals方法时，必须重写hashCode方法，保证两个对象euqals为true时，两对象的hashCode值一定相等。重写hashCode方法时，不用自己动手实现，可以选用Java已经实现hashCode方法的字段作为自己重写hashCode方法的一种选择，当然也可以自己设计一套哈希算法。hashCode值在使用键值对方式的数据结构中和从堆中快速取对象时用到。

5. iterator迭代器提供一种所有集合类通用的遍历方式，不论是List、Set还是Map，也不论是数组实现、链表实现还是哈希实现。迭代器实际的涉及的三个方法是 hasNext()、next()、remove()。并且在使用iterator遍历集合时，集合处于锁定状态，集合对象本身无法对自己进行添加和删除操作(只能看不能改)。而iterator自己的remove()方法可以对集合元素进行删除。hasNext()指向要访问对象的前面，next()做指针移动操作并返回移动后，指针左侧的元素。remove()方法移除访问指针左侧的元素。

6. 增强for循环不能通过下标直接访问数据，以及删除对应位置的元素，底层是通过iterator迭代器来实现集合的遍历。简单遍历时可以使用，其他情况不建议使用。

7. equals()方法在容器中进行添加(针对Set)、删除、查找、排序等涉及判断是否相等的操作中会用到，故自定义了类并添加到容器中，需要重写equals()方法，让容器类中相关方法能够正确的工作。hashCode()在容器中涉及键值对方式存储的数据结构时需要用到，主要针对HashMap&Hashtable&HashSet，若自定义了并添加到这些数据结构的容器中时，必须重写hashCode()方法，一方面保证定义的数据结果不被破坏，另一方保证容器类提供的方法能够正常工作。

8. compareTo()方法在对容器元素进行排序等涉及元素间比较的操作时会用到，使用集合框架提供的排序算法时，集合中的对象没有实现Compareable接口并重写compareTo()方法，排序算法不知如何比较元素间的大小，更谈不上对集合中的所有元素进行排序操作。

9. 通过接口传入参数, 可以隐藏实现该接口类的其他信息，也就是说，在方法中只能使用该接口定义的属性和方法。 

10. 泛型的引入相比使用Object最直接的影响是在对象操作之前，不需要做强制类型转换。其次，程序的可读性和稳定性会更好，程序在编译器会对容器中的类型做检查，避免了类型不明确的问题。


# **六、I/O流**

1. 流的分类：按数据流的方向可分为输入流(InputStream & Reader)与输出流(OutPutStream & Writer)；按处理数据单位可分为字节流(InputStream & OutputStream 以Stream结尾的流)与字符流(Reader & Writer 或以这两者结尾的流)；按功能可分为节点流和处理流(节点流为对数据做原始的传输，处理流对结点流数据进行筛选、包装等操作)

2. Serializable接口是一个标记性接口，其中没有任何方法的声明。实现该接口的类会被编译器视为可序列化的类，具体的序列化方式由Java本身来确定。Externalizable 继承于 Serializable接口，实现该接口的类同样具有序列化能力，不过具体序列化的方式由用户自己定义。


# **七、多线程**

1. 将一个实现Runnable接口的对象交给一个Thread并调用start()方法去执行，本质上是开了一个线程去执行重写的run()方法逻辑，该线程与主线程或调用线程并发执行。而通过实现Runnable接口的对象去直接调用run()方法，只是普通的方法嵌套调用，本质上不会开一个线程，与主线程或调用线程并发的执行run()方法的逻辑。区别：**方法调用和线程启动**！

2. 能通过实现Runnable接口的方式并交给Thread对象执行的方式创建新的线程，就不用直接继承Thread类，这样能提高程序的灵活性和可扩展性

3. Thread.sleep()在哪个线程中调用，哪个线程就睡眠。不要轻易调Thread的interrupt()，不要使用Thread的stop()。不要在catch块中做业务逻辑操作，这是一个不好的编程方式。

4. join() 谁调用就将谁合并到主线程或调用线程中去，将该线程变成与普通方法嵌套调用的一样的执行方式，即该线程的逻辑执行完后再执行主线程或调用线程的逻辑，

5. 线程设置较高的优先级在多线程的环境下运行相对能够获得较多的时间片去执行该线程的逻辑。

6. 同样一个实现Runnable接口的类的实例对象(线程对象)，可以交给不同线程执行。线程自然结束的标志是线程对象中run()方法执行完毕。(线程也可以非自然结束，如调用stop()、interrupt())

7. synchronize 关键字加在方法上代表该方法被线程执行时具有该方法所在类或类的对象的锁(实例方法对应实例对象的锁、静态方法对应类的锁)，而不是该方法的锁！方法不具有锁，具有锁的只有类和累的实例对象。加锁的粒度尽可能的小，这样可以提高程序运行的效率。拿着相应的锁去锁定相应的代码块，在运行的过程中，只有锁定的代码只允许获得相应锁的线程运行，而没有锁定代码块，可以同时被多个线程运行，不论是类锁还是对象锁。

8. 对于一个临界资源，我们需要考虑访问该临界资源的所有方法是否能够做到互斥访问，若存在不互斥访问的方法，在多线程的环境下，临界资源同样也会访问出错。

9. 在实例对象的方法中调用this.wait()，本质上是调用Object类的wait()方法，其含义为 当前访问本对象的线程wait()！调用this.wait() 的前提是访问该对象的线程获得了该对象的锁，这样才有资格wait()。也就是调用this.wait()的方法必须是synchronized的！

10. 在实例对象的方法中调用this.wait()，访问当前访问本对象的线程会释放该线程所持有的锁！这点与Thread.sleep()的方法有本质区别,在线程中执行Thread.sleep()方法，线程不会释放手中所持有的锁，并且在sleep指定时间后转为就绪态，获得时间片后继续执行。而this.wait()方法执行后，线程如果没有被唤醒的话将永久休眠，如被唤醒，则需重新获得类或对象锁后才能继续执行线程相关逻辑。

11. 在实例对象的方法中调用this.notify(),唤醒一个在本对象wait着的线程。若该对象上没有wait着的线程，notify方法没有任何作用效果。notifyAll()用于唤醒所有在本对象wait着的线程。注意:线程不能自己唤醒自己，线程也不能让其他线程等待！

12. 在多线程环境下，判断调剂是否成立并做带有潜在异常操作时，不要使用if，而要使用while!因为使用if当条件满足时进入的方法块(如执行wait操作)中发生异常并被catch到，if后的代码仍然会被执行，很显然，代码没有按照我们所设计的方式执行而发生错误。使用while就能有效避免这个问题，即使while块中的代码出现异常被catch到，执行catch代码块后同样会回来做设定条件的判断，直到while条件不满足或while块中的逻辑被正确执行为止。

13. 线程的简单理解：一个程序中不同的执行路径！



# **八、网络**

1. 