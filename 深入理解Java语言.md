<!-- TOC -->

- [**一、面向对象设计思想**](#一面向对象设计思想)
- [**二、异常处理**](#二异常处理)
- [**三、数组**](#三数组)
- [**四、常用类**](#四常用类)
- [**五、容器**](#五容器)
- [**六、I/O流**](#六io流)
- [**七、多线程**](#七多线程)
- [**八、网络**](#八网络)
- [**九、其他**](#九其他)

<!-- /TOC -->

# **一、面向对象设计思想**

1. 面向对象程序设计重要思想：**让合适的方法出现在合适类中**！遇到问题时**首先考虑该问题所涉及的类和对象**、类中所具有的属性和方法以及**类和对象与对象间的关系**，而不应该考虑怎么一步一步的完成完成任务！

2. **类是对象的抽象，对象是类的实例**，即Java中的每个类都对应现实对象的抽象！

3. **继承关系是一般与特殊的关系**；**聚合关系是整体和部分的关系**（聚集->松耦合 & 组合->紧耦合）；**实现关系是类对接口方法不同的解析**

4. 结构化程序设计的复用只能在**方法层面**的复用，而面向对象程序设计的复用可以在**对象层面**的复用； ->  **编程追求目标：可复用 & 可扩展**

5. 成员变量可以为基本类型和引用类型，且在编译时会进行初始化，具体在类加载阶段进行初始化(静态变量，对于实例变量在调用实例构造方法进行初始化)。**局部变量不会自动进行初始化**，故使用时需手动初始化

6. **方法重载的前提是编译器能够区分调用具体的方法**，方法的重载能使类的接口的使用更加方便，使用更加舒适

7. this:对那个对象调的方法，this就指该对象的引用！**this 是当前对象自身引用，super是当前对象的父类引用**

8. static修饰的变量被所有的实例对象共享，尽管这个实例对象指向null！ 

9. 变量分类：局部变量 & 成员变量(类变量/静态变量 & 实例变量)  方法分类：实例方法 & 类方法

10. 所有未加package的类称为**裸体类**，很容易发生引用冲突

11. 访问修饰符作用域大小：private、default(package)、protect、public.**注意protect访问修饰符在同一包内的均可访问，不只是继承关系才能访问**

12. 子类继承父类时，父类私有的对象同样继承下来了，只是在子类中没有访问权限，**但是继承下来了**！！！（对私有属性和方法，**子类具有所有权，但没有使用权**）

13. **重写方法不能比被重写方法有更严格的访问权限**，方法重写动机：**子类对从父类继承的方法不满意，需要重新定义**

14. 对象实例化中，给对象的属性赋值的操作：**默认初始化**(类加载过程中的的链接阶段) -> **显式初始化/初始化块**(类加载过程中的初始化阶段) -> **构造函数初始化**(类的构造方法)

15. 如果在子类构造方法中调用super方法，**必须在子类构造方法第一行调用super**；若没有显式调用父类构造方法，系统将会去调用父类没有参数的构造方法，若父类没有无参的构造方法，则调用默认构造方法。

16. 创建子类对象前，**需要将其所有父类加载到方法区，并调用相应的构造方法将该类的所有父类的实例对象创建好**。子类对象由父类对象扩展而来，故子类对象中包含父类对象，创建子类对象前先创建根父类Object的对象，**由上至下依次创建，最终将该子类对象**。

17. **父类可以指向之类对象，但不能访问子类新增的属性和方法！**

18. 多态的三个条件：**要有继承；要有重写；要有父类引用指向子类对象**。Java程序的多态是通过**动态绑定机制**实现，当一个方法的参数为基类对象，Java会根据运行时传入的子类对象调用子类重写该父类具体的方法，从而实现多态。

19. 抽象方法，抽象类：只有定义，没有实现的必要，**用于被子类继承和方法重写**。含有抽象方法的类表明该类是**残缺不全的**，即没有足够的信息支持定义一个完整的类的对象，**故含有抽象方法的类必为抽象类**。**故抽象方法必须被重写，抽象类必须被继承**；若一个类继承了抽象类但不知道抽象类中抽象方法的具体实现，**可以将抽象类中抽象方法继续声明为abstract**。

20. 本质上，**接口是特殊的抽象类**，**一般定义为某种能力**，当类实现接口时，表明该类获得了该接口声明的能力(**接口以able结尾，说明接口定义一种能力**)。抽象类中所有的方法都是抽象方法，且所有属性均为**public static final**(默认是且只能是，修正了C++多继承的属性重名的问题)。接口中所有方法均为abstract，无需显示声明。

21. 用接口去引用实现接口的实例对象，**该引用只能访问接口中定义的方法和属性**。**对于该类定义的其他方法，该引用是无法感知的**。

22. **Java 语言中方法重写的本质**:
    - 1)找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。
    - 2)如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束;如果不通过，则返回java.lang.IllegalAccessError异常。
    - 3)否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
    - 4)如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。


# **二、异常处理**

1. 当程序发生异常，**如果有捕获异常的代码块，则按照捕获异常的逻辑处理异常**；**若没有捕获异常的代码块，则程序将发生的异常抛出到上层调用处**，如此反复处理，若整个代码中没有处理异常的代码块，程序所发生的异常最终会被Java虚拟机捕获并处理，处理方式为 输出异常信息(printStackTrace()方法)

2. catch块中声明的异常型参，**在代码捕获到异常时，系统会自动创建一个对应异常类的对象并传入catch块中**，并在catch块中执行相应的异常处理逻辑。

3. **Throwable(Error & Exception(RuntimeException & OtherException) )**RuntimeException没有必要显式捕捉(在程序运行过程中经常发生，捕捉起来比较麻烦)，除此之外的Exception均需显式捕捉。(检查异常 & 非检查异常)

4. finally块中通常执行方法执行的善后工作，如资源的清除工作。注意：**关闭资源的操作同样容易抛出异常，所以需要在finally块中关闭资源时同样做try-catch操作，Java8 后提出try-with-resource 语句，避免了以往在finally中写嵌套的try-catch块。**

5. catch块中一定要对捕捉的异常进行处理，至少将捕获的异常信息打印出来。**不能将异常"吞掉"**！**任何的异常如果不想自己处理，可以在方法声明时throws相关异常**，main方法同样可以声明throws相关异常，并且java运行时系统可以捕捉并打印异常信息，但这是一种很不良好的编程习惯！

6. **自己能够处理的异常，一定要自己处理；自己不能处理的异常，一定要将异常抛出。绝不能将异常"吞掉"**

7. throw new SomeException; method() throws SomeException; **throw 用于在方法内部显式地抛出异常，而throws 用于声明方可能抛出的异常**。二者有本质区别！

8. 声明抛异常时，**需要精细化抛出，尽管所抛异常具有继承的关系！这是一种良好的编程习惯！**

9. 常见异常：OutOfMemoryError；StackOverFlowError；IndexOutOfBoundException；IOException；FileNotFoundException；NullPointerException；ArithmeticException；IllegalMonitorStateException



# **三、数组**

1. int[] arr = new int[5]; **数组是引用类型并在堆中分配内存**。(阿里Java开发规范建议，数组符号靠近类型即int[] ,而不推荐int a[])

2. 数组初始化：**动态初始化**(先为数组分配空间，在对数组中每个位置进行赋值) & **静态初始化**(为数组分配空间的同时进行赋值操作) & **默认初始化**(只为数组分配空间但不做赋值操作，Java会为数组每个位置进行默认初始化)；

3. length是数组对象的**属性**，故访问时采用数组对象array.length的方式。String中的length是String类中的**方法**，故获取当前字符串对象长度时需StringObject.length()

4. 数组一般作为连续的存储空间存在，数组复制时无需在一个一个的复制拷贝，而是将**整段数据直接进行拷贝**，System中ArrayCopy就是采用整段数据拷贝的方式，最快！

5. 二维数组的第一维装的是指向第二维数组的指针，分析清楚**内存结构**！



# **四、常用类**

1. String 不可变字符串，StringBuilder&StringBuffer 可变字符串；StringBuilder & StringBuffer 区别：**前者线程不安全，后者线程安全**。这也导致在单线程的环境下，StringBuilder 比 StringBuffer来的快。(字符串连接符+,在Java5及之前版本中使用StringBuffer实现，在后期使用的是StringBuilder实现)

2. File只代表某个文件或路径名，至于是目录还是文件可以通过isDirectory()方法判断。**new 出File 对象时只是在堆中创建一个File对象，在真实的物理盘上不会生成对应的文件或者文件夹**。



# **五、容器**

1. **容器类就是装其他各种对象的类**，具有增、删、改、查等操作的特点。

2. 为什么用容器所实现的接口去引用具体的容器类对象：**增加程序的灵活性**！**当你决定不使用现有的数据结构时，只需修改容器类，程序的其他部分无需做任何修改！**

3. 为什么容器中只能存放引用类型：与Java语言的发展历史有关，**在泛型没有提出之前，所有的容器盛放的都是Object类**，这就要就我们在编码时需要很清楚自己向容器中添加的数据类型并在操作前做强制类型转换，故从容器一开始就设计为存放引用类型。泛型的提出只是让编译器在程序编译时就对放入容器的类做类型检查，且无需我们手动做强制类型装换，提升的程序的可读性和健壮性。

4. **重写equals方法时，必须重写hashCode方法**，**保证两个对象euqals为true时，两对象的hashCode值一定相等**。重写hashCode方法时，不用自己动手实现，可以选用Java已经实现hashCode方法的字段作为自己重写hashCode方法的一种选择，当然也可以自己设计一套哈希算法。hashCode值在使用键值对方式的数据结构中和从堆中快速取对象时用到。

5. iterator迭代器提供一种所有集合类通用的遍历方式，不论是List、Set还是Map，也不论是数组实现、链表实现还是哈希实现。迭代器实际的涉及的三个方法是 **hasNext()、next()、remove()**。并且在使用iterator遍历集合时，**集合处于锁定状态**，集合对象本身无法对自己进行添加和删除操作(**只能看不能改**)。而iterator自己的remove()方法可以对集合元素进行删除。hasNext()指向要访问对象的左侧，next()做指针移动操作并返回移动后指针左侧的元素。remove()方法移除访问指针左侧的元素。

6. 增强for循环不能通过下标直接访问数据，以及删除对应位置的元素，**底层是通过iterator迭代器**来实现集合的遍历。简单遍历时可以使用，其他情况不建议使用。

7. **equals()方法在容器中进行添加(针对Set)、删除、查找等涉及判断是否相等的操作中会用到**，故自定义了类并添加到容器中，需要重写equals()方法，让容器类中相关方法能够正确的工作。**hashCode()在容器中涉及键值对方式存储的数据结构时需要用到**，主要针对HashMap&Hashtable&HashSet，若自定义了并添加到这些数据结构的容器中时，必须重写hashCode()方法，一方面保证定义的数据结构不被破坏，另一方保证容器类提供的方法能够正常工作。

8. **compareTo()方法在对容器元素进行排序等涉及元素间比较的操作时会用到**，使用集合框架提供的排序算法时，集合中的对象没有实现Compareable接口并重写compareTo()方法，排序算法不知如何比较元素间的大小，更谈不上对集合中的所有元素进行排序操作。

9. 通过接口传入参数, 可以**隐藏实现该接口类的其他信息**，也就是说，在方法中只能使用该接口定义的属性和方法，对于接口实现类的其他方法，该接口引用无法访问。 

10. 泛型的引入相比使用Object最直接的影响是在对象操作之前，**不需要做强制类型转换**。其次，程序的可读性和稳定性会更好，**程序在编译器会对容器中的类型做检查，避免了类型不明确的问题**。


# **六、I/O流**

1. 流的分类：按**数据流的方向**可分为输入流(InputStream & Reader)与输出流(OutPutStream & Writer)；按**处理数据单位**可分为字节流(InputStream & OutputStream 以Stream结尾的流)与字符流(Reader & Writer 或以这两者结尾的流)；按**功能**可分为节点流和处理流(节点流为对数据做原始的传输，处理流对结点流数据进行筛选、包装等操作)

2. Serializable接口是一个**标记性接口**，其中没有任何方法的声明。实现该接口的类会被**编译器**视为可序列化的类，具体的序列化方式由Java语言本身来确定。Externalizable 继承于 Serializable接口，实现该接口的类同样具有序列化能力，不过具体序列化的方式由用户自己定义。


# **七、多线程**

1. 将一个实现Runnable接口的对象交给一个Thread并调用start()方法去执行，**本质上是开了一个线程去执行重写的run()方法逻辑**，该线程与主线程或调用线程**并发执行**。而通过实现Runnable接口的对象去直接调用run()方法，只是普通的**方法嵌套调用**，本质上不会开一个线程，**与主线程或调用线程并发的执行run()方法的逻辑**。区别：**方法调用和线程启动**！

2. 能通过实现Runnable接口的方式并交给Thread对象执行的方式创建新的线程，就不用直接继承Thread类，这样能提高程序的**灵活性和可扩展性**

3. **Thread.sleep()在哪个线程中调用，哪个线程就睡眠**。不要轻易调Thread的interrupt()，不要使用Thread的stop()。**不要在catch块中做业务逻辑操作，这是一个不好的编程方式。**

4. join() 谁调用就将谁合并到主线程或调用线程中去，将该线程变成与**普通方法嵌套调用**的一样的执行方式，即该**线程的逻辑执行完后再执行主线程或调用线程**的逻辑，

5. 线程设置较高的优先级在多线程的环境下运行相对能够获得较多的时间片去执行该线程的逻辑，**但无法保证绝对的执行时间**。

6. **同样一个实现Runnable接口的类的实例对象**(线程对象)，可以交给不同线程执行。线程自然结束的标志是线程对象中run()方法执行完毕。(线程也可以非自然结束，如调用stop()、interrupt())

7. synchronize 关键字加在方法上代表该方法被线程执行时具有该方法所在**类或类的对象的锁**(实例方法对应实例对象的锁、静态方法对应类的锁)，而不是该方法的锁！方法不具有锁，具有锁的只有类和类的实例对象。**加锁的粒度尽可能的小**，这样可以提高程序运行的效率。拿着相应的锁去锁定相应的代码块，在运行的过程中，**只有锁定的代码允许获得相应锁的线程运行，而没有锁定代码块，可以同时被多个线程运行，不论是类锁还是对象锁**。

8. 对于一个临界资源，我们需要考虑访问该临界资源的**所有方法是否能够做到互斥访问**，若存在不互斥访问的方法，在多线程的环境下，临界资源同样也会访问出错。

9. 在实例对象的方法中调用this.wait()，本质上是调用Object类的wait()方法，其含义为 **当前访问本对象的线程wait()**！调用this.wait() 的前提是**访问该对象的线程获得了该对象的锁**，这样才有资格wait()。**也就是调用this.wait()的方法必须是synchronized的**！(否则报 IllegalMonitorStateException 异常)

10. 在实例对象的方法中调用this.wait()，**当前访问本对象的线程会释放该线程所持有的锁**！这点与Thread.sleep()的方法有本质区别,**在线程中执行Thread.sleep()方法，线程不会释放手中所持有的锁，并且在sleep指定时间后转为就绪态，获得时间片后继续执行**。而this.wait()方法执行后，**线程如果没有被唤醒的话将永久休眠**，如被唤醒，则需重新获得类或对象锁后才能继续执行线程相关逻辑。

11. 在实例对象的方法中调用this.notify(),唤醒一个在本对象wait着的线程。若该对象上没有wait着的线程，notify方法没有任何作用效果。notifyAll()用于唤醒所有在本对象wait着的线程。注意:**线程不能自己唤醒自己，线程也不能让其他线程等待！**

12. 在多线程环境下，判断条件是否成立并做带有潜在异常操作时，**不要使用if，而要使用while**! 因为使用if当条件满足时进入的方法块(如执行wait操作)中发生异常并被catch到，if后的代码仍然会被执行，很显然，代码没有按照我们所设计的方式执行而发生错误。使用while就能有效避免这个问题，即使while块中的代码出现异常被catch到，执行catch代码块后同样会回来做设定条件的判断，直到while条件不满足或while块中的逻辑被正确执行为止。

13. **线程的简单理解：一个程序中不同的执行路径！**(方法嵌套调用 & 多线程执行 两者的程序运行图)



# **八、网络**

1. 网络中两个节点能够相互通讯，就像两个人能够相互沟通。**两个人若能相互沟通，则他们使用的是相同的语言；网络上的两个节点能够相互通信，则他们使用的是相同的通讯协议**。

2. **通信协议分层思想的好处**:①开发过工作会更加容易，无需在实现底层的具体细节；②对于资源的分配更加灵活，若某一层实现的资源不够时，可以只针对那一层的资源进行扩展，这样更具有针对性和灵活性。分层的思想在开发的场景中应用比较广泛，是一种较好的程序设计思想。

3. TCP/IP 模型(也是实际应用时所分的层次)由底至上分为：物理层、网络层(IP层)、传输层(TCP/UDP层)、应用层(我们所编写的层)。**可以看出我们开发过程中与传输层打交道，即考虑使用TCP还是UDP协议对数据数据进行传输**。

4. IP地址分为两个部分：**网络地址+物理地址**。对于IPv4来说，IP中的网络地址占第一个字节为A类网，占前两个字节为B类网，占前三个字节为C类网。不同的网络类型，意味着在此网段下的物理机的数量最多能够分配多少台。不过可以采用内网机制，一台机器作为访问外网的路由器，内网中的所有物理机可通过该具有路由功能的机器访问外网，不过内网所有机器对外的IP是一样的，均为那台与外网相连并具有路由功能的机器。(该机器会具有两块网卡，一块连接公网，另一块连接内网所有机器)

5. TCP传输协议具有**可靠性**，**首先需要传输数据的双方建立起连接；其次在每次传输数据包时均需确认收到**。UDP传输协议是一种**不可靠**的数据传输协议，**首先传输数据的双方不需建立起连接；其次数据的发送方无需知道数据的接收方是否收到数据包，数据的接收方也不会向数据的发送方回复说数据已收到**。前者可靠但数据传输比较慢，后者则相反。

6. **端口号用于区分同一台机器上不同的应用程序**，即同一台机器上的不同应用程序和服务可以通过不同的端口号来分别访问。自己变成程序一般用1024以上的端口号，1024以下的系统可能会占用。端口号类型又可分为TCP和UDP端口。

7. Socket编程中，服务端ServerSocket需指定服务的端口号，启动时会**阻塞式**的监听该端口号并等待客户端的接入。对于客户端Socket需要指定服务端的IP地址和端口号，至于自己使用什么端口号来访问服务端，有系统自行分配决定。



# **九、其他**

1. Java变量分类：局部变量 & 成员变量；其中成员变量又可分为 静态变量(类变量) & 实例变量)

2. 数组为空，不代表数组没有创建；**数组一旦创建，其长度就是确定的**

3. 多态的使用前提：**类的继承关系；方法的重写；父类引用指向子类对象**。

4. **静态方法不能被重写**！**父类、子类可具有同名的静态方法，但不是重写**！

5. 何为线程安全：1.**如果只有一个线程才可以操作此数据，则必是线程安全的**；2.如果有多个线程操作此数据，则此数据是共享数据，如不考虑同步机制的话，会存在线程安全问题

6. 静态初始化块(类的初始化，即类在加载到内存时所执行的代码块，而每个类只被加载一次，静态代码块只会被执行一次)；初始化块(每个类的对象创建时均会执行的代码块)；构造函数(类的特定对象创建时执行的代码块)

7. **类的初始化**，即在类加载阶段中的初始化操作，对应的虚拟机层面的方法为 **clinit**;**类对象的初始化**，即在方法中创建类的对象并在堆中分配实例内存时的操作，对应的虚拟机层面的方法为 **init**

8. Java方法分类：实例方法 & 类方法

9. String str = "Hello";// 字面量定义  String str = new String("Hello");// 对象创建定义。其中，以字面量形式定义的字符串会自动添加到字符串常量池中，而用new的方式创建字符串对象会在堆中分配内存(堆中处字符串常量池以外的区域)存储该字符串对象，因此不会添加到字符串常量池中。如需将该字符串对象存储的字符串动态添加到字符串常量池，调用intern()方法即可。

10. **String的底层实现由Java8及以前的char数组编程Java8以后的byte数组**。而数组在编译时长度就确定了，故字符串是一个不可变的对象

11. String的intern()方法:在程序运行时，向字符串常量池(字符串常量表StringTable)中动态添加字符串常量。如果字符串常量池中没有添加的字符串，则在常量池中添加新的字符串常量，若字符串常量池中存在要添加的字符串，则不再重新添加，复用已有字符串即可，判断要添加的字符串常量是否存在，是通过Hashtable的哈希算法来判断。Java6及之前的Hashtable长度为1009，Java7之后的Hashtable长度为60013，Hashtable长度的增加可以降低字符串常量添加时的哈希冲突，提高判断字符串是否存在的效率。

12. **intern()方法的执行过程：**先通过hashcode判断要添加的字符串是否存在于字符串常量池，若存在则返回该字符串在常量池中的地址。若不存在，则在字符串常量池中分配内存存储该字符串。

13. Java在做字符串拼接操作时，若"+"号左右有变量存(非final)在，则底层会创建StringBuilder对象并调用append()方法做字符串的链接操作。**说明：在Java5之前使用的是StringBuffer对象来做字符串的连接操作，该类线程安全，但性能较低，故更换为StringBuilder**。若字符串拼接操作的两端均为字符串常量或字符串常量的引用(final修饰的字符串)，则使用编译期优化，底层实现同字符串常量的连接操作。建议：在定义各种量时，能够使用final时建议加上final!

14. 字符串连接操作的两种方式:① 采用字符串连接操作符的形式 ② 采用StringBuilder对象并调用append()方法的方式；**相比之下，前者每次做连接操作时需要创建一个StringBuilder对象和调用toString()方法时，需要创建String对象**。一方面在需要做大量连接操作的场景中，每次连接操作创建对象需要花费一定时间，另一方面，创建的对象会占用堆空间的内存并在进行垃圾回收时需要花费一定时间。对于使用StringBuilder对象并调用append()方法的方式，不论做多少次字符串的连接操作，始终只有一个StringBuilder对象存在，可以优化的点在于创建StringBuilder对象时可以根据具体业务需求指定StringBuilder的大小，减少StringBuilder对象频繁扩容所带来的额外开销。

15. 创建字符串常量并添加到字符串常量池方式：①通过字面量的方式定义字符串 String str = "java"; ②通过 ***.intern()的方式向常量池中动态添加字符串常量，具体形式如 String str = new String("java").intern() | new StringBuilder("java").toString().intern()。

